---
title: "Introduction to spatial tasks with R"
author: "Francois Rousseu"
date: '2017-07-17'
output:
  html_document:
    depth: 4
    fig_height: 5
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: no
  beamer_presentation: null
  html_notebook:
    number_sections: no
    toc: yes
    toc_depth: 4
  ioslides_presentation:
    smaller: yes
    transition: faster
    widescreen: yes
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: 4
geometry: left=2cm,right=2cm,top=3cm,bottom=2.5cm
always_allow_html: yes
---

<script>
   $(document).ready(function() {
     $head = $('#header');
     $head.prepend('<img src=\"cef.gif\" style=\"float: right;width: 75px;\"/>')
   });
</script>

<style>
pre.r {
    background-color: #EEEEEE!important;
    border-color: #EEEEEE!important;
}
</style>

<style>
  .main-container {
    max-width: 1300px !important;
  }
</style>

```{r options, include=TRUE, cache=FALSE, echo=FALSE, message=FALSE}
options(width=80)
knitr::opts_chunk$set(cache=TRUE,comment="##",echo=TRUE,message=FALSE,warning=FALSE,tidy=TRUE,size="small",fig.align="center",out.width="100%")

```

# INTRODUCTION

The main book for learning to use R for spatial data is probably [Applied Spatial Data Analysis with R](http://www.asdar-book.org/) by Bivand et al. (2013)

# SHAPEFILES

The main packages directly used for working with shapefiles and doing spatial operations are sp, rgdal and rgeos.
<br>

| Package | Use |
| :-------------:|:----------------------------------------|
| **sp** | Defines S4 spatial classes and methods for manipulating spatial objects |
| **rgdal** | Provides bindings with the GDAL and PROJ.4 libraries for reading, projections, coordinate transformations, etc. |
| **rgeos** | Provides bindings for the GEOS library for spatial operations (intersections, buffers, etc.) | 
| **maptools** |  | 
| **sf** | New S3 spatial classes and methods for manipulating spatial objects as simple features |
| **spdep** | Tools for studying spatial dependence |

<br>

## Reading and writing

### Reading

Reading shapefiles is done with the function `readOGR` from the `rgdal` package.

```{r read}

library(sp)
library(rgdal)
#roads<-readOGR(dsn="C:/Users/rouf1703/Documents/UdeS/Consultation/M-LLecuyer/Doc",layer="roads",verbose=FALSE,encoding="UTF-8")
roads<-readOGR(dsn="C:/Users/rouf1703/Documents/UdeS/Consultation/M-LLecuyer/Doc",layer="carreteras",verbose=FALSE,encoding="UTF-8")
#pop<-readOGR(dsn="C:/Users/rouf1703/Documents/UdeS/Consultation/M-LLecuyer/Doc",layer="pop",verbose=FALSE,encoding="UTF-8")

class(roads)

```


```{r read2, out.width="70%"}

library(scales) # to use alpha for adding transparency

plot(roads,col=gray(0.75),lwd=4, axes=TRUE)

```


### Writing

```{r write, eval=FALSE}

writeOGR(roads,dsn="C:/Users/rouf1703/Documents/UdeS/Consultation/M-LLecuyer/Doc",layer="cat",driver="ESRI Shapefile")

```

## Building shapefiles

### From a `data.frame`

Let's load some data that contains locations of Jaguars attacks in the kalakmul reserve in Mexico. Interviews were done with farmers about whether attacks from jaguars (or cougars) happened with their cattle. 

```{r shpdf1}

cat<-read.table("C:/Users/rouf1703/Documents/UdeS/Consultation/M-LLecuyer/Doc/cat.txt",header=TRUE,stringsAsFactors=FALSE)
head(cat)

```

This is a simple data.frame with X and Y columns representing longitudes and latitudes. To transform this data.frame to a spatial object, we just have to do this:
```{r shpdf2}

library(sp)
coordinates(cat)<-~X+Y
class(cat)

```

The object returned is now a `SpatialPointsDataFrame`. This object can be simply plotted with the function plot which has a method for Spatial objects.

```{r shpdf3, out.width="60%"}

plot(cat,col=alpha(ifelse(cat$Attack==0,"blue","red"),0.4),pch=16,cex=1.5,axes=TRUE)

```


### From scratch

```{r shpscratch, out.width="50%"}

set.seed(123)
n<-10
x1<-rnorm(n,0,1)
y1<-rnorm(n,0,1)
id<-1:n
x<-SpatialPointsDataFrame(cbind(x1,y1),data=data.frame(id))
head(x)
plot(x,axes=TRUE)

```

To close a polygon, the last point of the matrix needs to be the first point that starts the polygon.
```{r xscratchpol, out.width="50%"}

library(magrittr)

m<-rbind(c(1,1),c(1,2),c(2,2),c(3,2),c(2,1))

z<-rbind(m, m[1, ]) %>% 
  Polygon %>% 
  list %>% 
  Polygons(ID = 1) %>% 
  list %>% 
  SpatialPolygons

plot(z,axes=TRUE)

```


## Accessing data with S4 class

### The `Spatial` class with `sp`

```{r class}

getClass("Spatial")

```

## Spatial operations

Most spatial operations are done using the package `rgeos`. One of the requirement of the functions is that objects should be projected. When objects are really large, some operation may start to take a long time (e.g. intersections).

### Cut or delimit things

Here are some common operations that can be done on points (but also lines or polygons.

```{r points_op, fig.width=7,fig.height=4,out.width="100%"}
library(rgeos)

op<-c("gCentroid","gEnvelope","gConvexHull","gBuffer","gDelaunayTriangulation")
par(mfrow=c(2,3),mar=c(0,0,3,0))
for(i in seq_along(op)){
  plot(x,main=op[i],xlim=c(-2,2),ylim=c(-3,3))
  plot(get(op[i])(x),col=gray(0.5,0.5),add=TRUE,pch=16,cex=3)
}

```

Here are some common operations that are done on polygons.

```{r polygons_op, fig.width=7, fig.height=4,out.width="100%"}

x1<-gBuffer(x[1,],width=1)
x2<-gBuffer(x[2,],width=1)

op<-c("gIntersection","gDifference","gSymdifference","gUnion")
par(mfrow=c(2,2),mar=c(0,0,3,0))
for(i in seq_along(op)){
  plot(x1,main=op[i],xlim=c(-2,2),ylim=c(-3,3))
  plot(x2,add=TRUE)
  plot(get(op[i])(x1,x2),add=TRUE,col="red")
}

```


### Measure things

```{r measure_distance, out.width="60%"}

cx<-gCentroid(x)
plot(x,axes=TRUE)
plot(cx,add=TRUE,col="red",lwd=3)
text(x,round(gDistance(x,cx,byid=TRUE),2),adj=c(0,1.3),cex=0.8)

```


```{r measure_area, fig.width=7,fig.height=5,out.width="70%"}

ch<-gDelaunayTriangulation(x)
area<-gArea(ch,byid=TRUE)
plot(ch,axes=TRUE)
polygonsLabel(ch,labels=round(area,2),cex=0.4,gridpoints=1000)

```

### Sample things

Sample points in polygons in different ways using the `spsample` function.

```{r sample, fig.width=7,fig.height=5,out.width="70%"}

set.seed(12345)

n<-50
type<-c("random","stratified","regular","hexagonal")
par(mfrow=c(2,2),mar=c(0,0,2,0))
for(i in seq_along(type)){
  s<-spsample(z,n,type=type[i])  
  plot(z,main=type[i],font=2)
  plot(s,pch=1,add=TRUE)
}

```

Random points can also be distributed within random polygons
```{r sample2, fig.width=7,fig.height=5,out.width="70%"}

set.seed(12345)

N<-10 # number of random polygons
n<-5 # number of random points within each polygons

plot(z)
s1<-gBuffer(spsample(z,N,type="random"),byid=TRUE,width=0.1)
plot(s1,add=TRUE)
s2<-sapply(s1@polygons,spsample,n=n,type="random")
s2<-do.call("rbind",s2)
plot(s2,add=TRUE)

```

### Overlay things

Here we combine an over with Intersection, Length, buffers, etc.

```{r over, fig.width=8,fig.height=7,out.width="60%",echo=TRUE}
library(scales)
library(TeachingDemos)
b<-gEnvelope(roads)
set.seed(1234)
s<-spsample(b,n=10,type="random")
buffs<-gBuffer(s,width=10000,byid=TRUE)
plot(b)
plot(roads,add=TRUE,col=gray(0.7))
plot(s,add=TRUE)
plot(buffs,add=TRUE,border=NA,col=gray(0,0.1))
```

Let's determine which buffer touch any road.

```{r over2, fig.width=8,fig.height=7,out.width="60%",echo=-(1:10)}
<<over>>
o<-over(buffs,roads)
plot(buffs[apply(o,1,function(i){!all(is.na(i))}),],col=alpha("darkgreen",0.3),border=NA,lwd=2,add=TRUE)
```

Extract sections of road that intersect with a buffer.

```{r over3, fig.width=8,fig.height=7,out.width="60%",echo=-(1:12)}
<<over2>>
int<-gIntersection(buffs,roads,byid=TRUE)
plot(int,col="red",lwd=4,add=TRUE)
```

Finally, calculate the total lengths of roads inside every buffer.

```{r over4, fig.width=8,fig.height=7,out.width="60%",echo=-(1:14)}
<<over3>>
o<-over(buffs,int,returnList=TRUE)
dist<-sapply(o,function(i){
  sum(gLength(int[i],byid=TRUE))  
})
shadowtext(coordinates(buffs),labels=round(dist/1000,1),col="black",bg="white",adj=c(-1,-2))
```

### Simplify things

```{r simplify, out.width="50%"}

n<-50
x<-rnorm(n)
y<-rnorm(n)
poly<-gBuffer(SpatialPoints(cbind(x,y)),width=0.5)
plot(poly)
plot(gSimplify(poly,tol=0.6,topologyPreserve=TRUE),border="red",add=TRUE)

```

```{r temp, out.width="50%"}

library(rgbif)

p<-occ_search(scientificName="Phragmites australis",limit=3000,hasCoordinate=TRUE,country="CA")
p<-data.frame(p$data)
p$stateProvince<-as.factor(p$stateProvince)
coordinates(p)<-~decimalLongitude+decimalLatitude
class(p)
plot(p,axes=TRUE)

```

#### spsample, elide, mst

## Plotting

### plot

```{r plot, out.width="50%"}

par(mar=c(0,0,0,0))
plot(ch,border="red",col="blue",lwd=10)

```

### spplot

```{r spplot, out.width="80%"}


```

## S4 objects

### Access slots with @

```{r S4names}
names(p)[1:10]
```


```{r S4slots}
slotNames(p)
```


```{r S4slots2}
head(p@data)[,1:10]
```

```{r S4slots3}
p@bbox
```

Extractions of elements in spatial objects stored in slots are made either by accessing them using slots (with `@` instead of `$` which access columns in the `data.frame` attribute table stored in `@data`) or more easily with extractor function such as `bbox`, `proj4string` or `coordinates`.

```{r S4slots4}
p$copper
```


# PROJECTIONS

As always, when playing with spatial data, one needs to be aware of projections. Assigning and transforming projections in R is not to difficult. It is mostly done with the `proj4string` and `spTransform` functions from package **rgdal**. 

```{r proj_data, fig.width=6.5,fig.height=4,out.width="100%"}

library(rgbif)

x<-occ_search(scientificName="Phragmites australis",limit=3000,hasCoordinate=TRUE,country="CA")
x<-as.data.frame(x$data)
coordinates(x)<-~decimalLongitude+decimalLatitude

```

## Assign a projection

```{r proj_assign}

proj4string(x)
proj4string(x)<-CRS("+proj=longlat +datum=WGS84 +ellps=WGS84")
proj4string(x)

```

## Change a projection

```{r proj_change, fig.width=10, fig.height=6}

canada<-readOGR("C:/Users/rouf1703/Documents/UdeS/Formation/Canada",layer="Canada")
proj4string(canada)

crs<-c("+proj=longlat +datum=WGS84 +ellps=WGS84",
       "+proj=utm +zone=18 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0",
       "+proj=utm +zone=10 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0",
       "+proj=laea +lat_0=34 +lon_0=-10 +ellps=GRS80")

par(mfrow=c(2,2),mar=c(2,3,2,0))

for(i in 1:length(crs)){
  canada2<-spTransform(canada,CRS(crs[i]))
  x2<-spTransform(x,CRS(crs[i]))
  plot(canada2,axes=TRUE,main=crs[i],cex.main=0.7)
  plot(x2,add=TRUE) 
  
}


```

## Projections and EPSG

Projections can also be given with their epsg number. More info on projections can be found here [epsg.io](http://epsg.io/) where a list of the different epsg is available

```{r proj_epsg}

x<-spTransform(x,CRS("+init=epsg:4326"))
proj4string(x)

```

All functions from package rgeos require that Spatial object are projected, otherwise, functions do not work or assume that calculations are done on cartesian coordinates and return a warning message.  

# RASTERS

## What is a raster?

A raster is a regular grid of pixel with values. Here is an example of building a simple raster with random values.
```{r buildrastersimple}
library(raster)

n<-200
r<-raster(nrow=n,ncol=n,ext=extent(canada))
r<-setValues(r,runif(n^2))
proj4string(r)<-proj4string(canada)
ncell(r)
plot(r)
plot(canada,add=TRUE)

```

Here is an example of building a raster where each pixel value is determined by the number of points in each cell.
```{r buildrastercomplex}

x<-occ_search(scientificName="Catharus bicknelli",limit=5000,hasCoordinate=TRUE,country="CA")
x<-as.data.frame(x$data)
coordinates(x)<-~decimalLongitude+decimalLatitude
proj4string(x)<-CRS("+init=epsg:4326")
x<-spTransform(x,CRS(proj4string(r)))


#x<-spTransform(x,CRS(proj4string(canada)))


#x<-rgamma(100000,3)
#y<-rgamma(100000,3)
#s<-SpatialPoints(cbind(x,y))
#r<-raster(nrow=100,ncol=100,ext=extent(s))
#r<-rasterize(s,r,field=1,fun="count",background=0)
r<-rasterize(x,r,field=1,fun="count",background=0)

r[r==0]<-NA # everything 0 we won't plot

plot(canada,col=gray(0.9),xlim=unname(bbox(x)[1,]),ylim=unname(bbox(x)[2,]))
plot(r,col=rev(heat.colors(100)),add=TRUE)
#points(x,col=gray(0,0.05),cex=0.2)

```

## Raster formats

## Read, write, merge, crop

```{r read_rast}

r1<-raster("C:/Users/rouf1703/Documents/UdeS/Formation/cdem_dem_021E_tif/cdem_dem_021E.tif")
r2<-raster("C:/Users/rouf1703/Documents/UdeS/Formation/cdem_dem_031H_tif/cdem_dem_031H.tif")
par(mfrow=1:2)
plot(r1)
plot(r2)

r1

```


```{r merge}

r1<-aggregate(r1,10)
r2<-aggregate(r2,10)
r<-merge(r1,r2)
plot(r)

```


```{r crop}

e <- extent(-72.75, -70.25, 45, 46)
r <- crop(r, e)
plot(r)

```

## Stacks and Bricks

```{r stack}



```


## Raster operations

### Summarize


```{r summ}

r

```

### Extract

```{r extract}

e<-extract(r,x)
hist(e,xlab="Altitude",main="")

```

Speeding things up with `velox`

```{r velox}
library(velox)
library(microbenchmark)

rv<-velox(r)

buff<-gBuffer(x,byid=TRUE,width=0.05)
plot(r)
plot(buff,add=TRUE)

system.time(extract(r,buff,fun=mean))
system.time(rv$extract(buff,fun=mean))

```

### Reclassify

```{r reclassify}

mn<-c(0,100,200,400,600,800)
mx<-c(100,200,400,600,800,1200)
mat<-cbind(mn,mx,lab=mx)
mat
rc<-reclassify(r,mat)
plot(rc,col=terrain.colors(nrow(mat)))

```


### Reclassify

```{r measure_raster}

library(RColorBrewer)
library(FRutils)

roads2<-spTransform(roads,CRS("+proj=utm +zone=18 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0"))
rast<-raster(ncol=200,nrow=200,ext=extent(roads2))
rast_centroids<-xyFromCell(rast,1:ncell(rast),spatial=TRUE)
g<-gDistance(rast_centroids,gLineMerge(roads2),byid=TRUE)
class(g)
dim(g)
rast<-setValues(rast,g[1,])
val<-pretty(seq(min(minValue(rast)),max(maxValue(rast)),length.out=100),10)
lab<-list(at=val,labels=val)
plot(rast,col=colo.scale(1:99,rev(brewer.pal(9,"YlOrRd"))),breaks=99,axis.args=lab)
plot(roads2,add=TRUE)

```


## Spatial Autocorrelation

```{r SA}

library(spdep)

#neighbours <- poly2nb(cat)


```


### random walk and cost

```{r rw, out.width="60%"}

set.seed(123)

n<-1000
e<-extent(rast)

x<-c(extent(rast)[1])+cumsum(rnorm(n,0,2000)+500)
y<-c(extent(rast)[3])+cumsum(rnorm(n,0,2000)+500)
#plot(rast)

l<-Line(cbind(x,y)) %>% 
  list %>% 
  Lines(ID = 1) %>% 
  list %>% 
  SpatialLines

plot(rast,col=colo.scale(1:99,rev(brewer.pal(9,"YlOrRd"))),breaks=99,axis.args=lab)
plot(roads2,add=TRUE)
plot(l,add=TRUE,col="blue",lwd=2)

e<-extract(rast,l)

hist(e[[1]])


```

Road density

```{r road_density, out.width="60%"}

test<-rasterize(roads2,aggregate(rast,20),fun="length")
plot(test)
plot(roads2,add=TRUE)

```



### Countour and rasterToContours





## From shp to raster and back

### Rasterizing a polygon

```{r rasterizepol}

pr<-rasterize(buff,r)
pr
plot(pr)

```

### Polygonizing a raster

## Plotting with `rasterVis`

## `SpatialGrids` and `SpatialPixels`

## Grids

## Pixels

# STATIC MAPPING

## `plot`

```{r }


```

## `levelplot`

```{r }


```

## `spplot`

## `ggplot` and `ggmap`

## `ggspatial`

## chloropleth mapping

# INTERACTIVE MAPPING

select, drawPoly from package raster to interactively select elements

```{r drawPoly}

plot(x)
#pol<-drawPoly()
#plot(pol,add=TRUE,col="red")


```

## `OpenStreetMap`

```{r }
library(dismo)
#library(OpenStreetMap)

test<-gmap(p,type="roadmap",filename="map.gmap",scale=2)
proj4string(p)<-CRS("+init=epsg:4326")

p<-spTransform(p,CRS(proj4string(test)))
test<-crop(test,p)
plot(test)
plot(p,add=TRUE)

```

## `ggmap`

```{r }
library(ggmap)

test<-gmap("Sherbrooke",type="satellite",filename="map.gmap",scale=2,zoom=15,rgb=FALSE)
plot(test)

qmap("Sherbrooke",zoom=15,maptype="satellite")

```

## `leaflet`

Here present leaflet and leafletExtras

```{r leaflet1, tidy=FALSE}

library(leaflet)
library(leaflet.extras)

leaflet(cat) %>% 
  addTiles() %>%
  addCircleMarkers(data = cat, group = 'cat') %>%
  addDrawToolbar(targetGroup = 'cat', editOptions = editToolbarOptions(selectedPathOptions = selectedPathOptions())) %>%
  addLayersControl(overlayGroups = c('cat'),options =layersControlOptions(collapsed=FALSE)) %>%
  addMeasurePathToolbar(options =measurePathOptions(imperial = TRUE,minPixelDistance = 100,showDistances = FALSE))


```

## `tmap` 

```{r tmap, out.width="100%"}

cat$attack<-as.factor(cat$Attack)

library(tmap)
tmap_mode("view")
tm_shape(roads)+
  tm_lines()+
  tm_shape(cat)+
  tm_dots("attack")+
  tm_layout(basemaps=c("Esri.WorldImagery","Esri.WorldShadedRelief","Esri.NatGeoWorldMap"))

```

## `mapview`

```{r }


```

## `mapedit`

Here is a test with using [mapedit](http://r-spatial.org/r/2017/06/09/mapedit_0-2-0.html) functionality.

```{r mapedit, eval=FALSE}
library(mapview)
library(mapedit)
library(sp)

x <- mapview() %>% editMap()
plot(x)
x <- as(x[[1]],"Spatial")
plot(x)

#x<-editMap(leaflet() %>% addTiles())
#plot(x[[1]])

```

# MORE POSSIBILITIES

## Spatial Task View

## Reference Site: rspatial.org

A good online reference for doing spatial analyses with R is [rspatial.org](rspatial.org) which provides lots of examples on diferent types of analyses.

![rspatial.org](C:/Users/rouf1703/Documents/UdeS/GitHub/spatialR/rspatial.png)

## Special packages

### Landscape metrics with `spatialECO` or `SDMTools`

```{r metrics1}

library(spatialEco)


r <- raster(nrows=500, ncols=500, xmn=0, xmx=100, ymn=0, 
            ymx=100)

x<-runif(100,0,100)
y<-runif(100,0,100)

h<-gBuffer(SpatialPoints(cbind(x,y)),width=5)


r<-rasterize(h,r)

plot(r,col="green4")


x <- sampleRandom(r,1, na.rm = TRUE, sp = TRUE)
pol<-SpatialPolygonsDataFrame(gBuffer(x,width=20),data.frame(id=1),match.ID=FALSE)

a<-land.metrics(x=pol,y=r,metrics = c(2:38))

plot(pol,add=TRUE)
#plot(rasterToPolygons(r),add=TRUE)
plot(x,add=TRUE)

a

```

### Spatial statistics with `spatstat`

### Spatial dependence with `spdep`

### Kriging with `gstat`

### Animal movements with `adehabitat` and `trip`

### Kernel smoothing with `ks`

### Great circles with `geosphere`

## Extensions

### RQGIS

### RpostGIS

### RGRASS

# `sf`: THE NEW SPATIAL

## Why?

### S3 classes

### Tidyverse

### From `sp` to `sf` and back

