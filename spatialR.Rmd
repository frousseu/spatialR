---
title:    |  
      | INTRODUCTION TO    
      | SPATIAL TASKS WITH R
output:
  html_document:
    depth: 4
    fig_height: 5
    fig_width: 6
    number_sections: no
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: no
  beamer_presentation:
    colortheme: lily
    fonttheme: structurebold
    slide_level: 2
    theme: Singapore
    toc: yes
  html_notebook:
    number_sections: no
    toc: yes
    toc_depth: 4
  ioslides_presentation:
    smaller: yes
    transition: faster
    widescreen: yes
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: 4
geometry: left=2cm,right=2cm,top=3cm,bottom=2.5cm
always_allow_html: yes
---

<!-- <script> -->
   <!-- $(document).ready(function() { -->
     <!-- $head = $('#header'); -->
     <!-- $head.prepend('<img src=\"cef.gif\" style=\"float: right;width: 75px;\"/>') -->
   <!-- }); -->
<!-- </script> -->


<script>
    $(document).ready(function() {
      $items = $('div#TOC li');
      $items.each(function(idx) {
        num_ul = $(this).parentsUntil('#TOC').length;
        $(this).css({'text-indent': num_ul * 20, 'padding-left': 0});
      });

    });
</script>


<style>

pre.r {
    background-color: #EEEEEE!important;
    border-color: #EEEEEE!important;
    font-size: 12pt;
}

pre code {
  font-size: 12pt;
}

body {
  font-size: 12pt;
}

.main-container {
    max-width: 1300px !important;
}

#TOC {
  font-size: 11pt;
  border-color: white;
}

.list-group-item.active:focus{
    z-index: 2;
    color: darkgreen;
    background-color: #EEEEEE;
    border-color: red;
    font-weight: bolder;
    font-color: red;
}

.list-group-item.active:hover {
    z-index: 2;
    color: darkgreen;
    background-color: #EEEEEE;
    border-color: red;
    font-weight: bolder;
    font-color: red;
}

.list-group-item.active{
    z-index: 2;
    color: darkgreen;
    background-color: #EEEEEE;
    border-color: red;
    font-weight: bolder;
    font-color: red;
}

h1.title {
  margin-top: 90px;
  font-size: 42px;
  color: DarkGreen;
  font-weight: bold;
}
h1 {
  padding-top: 90px;
  font-size: 42px;
  color: DarkGreen;
  font-weight: bold;
}
h2 {
  padding-top: 90px;
  font-size: 36px;
  color: DarkGreen;
  font-weight: bold;
}

h3 {
  padding-top: 90px;
  font-size: 32px;
  color: DarkGreen;
  font-weight: bold;
}
h4 {
  font-size: 28px;
  color: DarkGreen;
  font-weight: bold;
}
h5 {
  font-size: 26px;
  color: DarkGreen;
  font-weight: bold;
}

</style>


```{r options, include=TRUE, cache=FALSE, echo=FALSE, message=FALSE, eval=TRUE}
options(width=70)
knitr::opts_chunk$set(cache=TRUE,comment="##",eval=TRUE,error=TRUE,echo=TRUE,message=FALSE,warning=FALSE,tidy=TRUE,size="LARGE",fig.align="center",out.width="100%")

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

# INTRODUCTION

The R spatial environment for manipulating spatial objects is mostly made of two suites of packages, one for vector data (or shapefiles) (**sp**, **rgdal**, **rgeos**) and one for raster data (**raster**). Vector data correspond to coordinates that make either points, lines or polygons, while raster data mostly correspond to regularly gridded data.

More recently, the new package **sf** (for simple features) has been developped to simplify and improve manipulations and operations on spatial vector data. Here, I've chosen to focus on spatial objects from the sp package as a lot of other packages cannot deal with sf objects yet. Also, once sp objects are understood, it is really straigthforward to move to using sf instead.

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

# SHAPEFILES

The main packages used for handling shapefiles and doing spatial operations are listed below.

| Package | Use |
| :-------------:|:----------------------------------------|
| **sp** | Defines S4 spatial classes and methods for manipulating spatial objects |
| **rgdal** | Provides bindings with the GDAL and PROJ.4 libraries for reading, projections, coordinate transformations, etc. |
| **rgeos** | Provides bindings for the GEOS library for spatial operations (intersections, buffers, etc.) | 
| **maptools** | Tools for reading and handling spatial objects | 
| **sf** | New simpler S3 spatial classes and methods for manipulating spatial objects as simple features |

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>


## Reading and writing

### Reading

First, let's look in the folder where the shapefile is located.

```{r read1, size="tiny"}

list.files("C:/Users/rouf1703/Documents/UdeS/GitHub/spatialR/data")

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Reading shapefiles is done with the function `readOGR` from the `rgdal` package. 

```{r read2, size="tiny"}

library(sp)
library(rgdal)
roads<-readOGR(dsn="C:/Users/rouf1703/Documents/UdeS/GitHub/spatialR/data",layer="carreteras",encoding="UTF-8")
class(roads)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

This object can be simply plotted with the function `plot` which has a method for spatial objects.
```{r read3, out.width="70%"}

plot(roads,col=gray(0.75),lwd=4, axes=TRUE)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Writing


```{r write, eval=TRUE, tidy=TRUE}

writeOGR(roads,dsn="C:/Users/rouf1703/Documents/UdeS/GitHub/spatialR/data",layer="test",driver="ESRI Shapefile",overwrite=TRUE)
list.files("C:/Users/God/Documents/ML")

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## Building shapefiles

### From a `data.frame`

<!-- Let's load some data that contains locations of Jaguars attacks in the Kalakmul reserve in Mexico. Interviews were done with farmers about whether attacks from jaguars (or cougars) happened with their cattle.  -->


```{r shpdf1}

cat<-read.table("C:/Users/rouf1703/Documents/UdeS/GitHub/spatialR/data/cat.txt",header=TRUE,stringsAsFactors=FALSE)
head(cat)

```

This is a simple `data.frame` with X and Y columns representing longitudes and latitudes. 

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

To transform this `data.frame` to a spatial object, we just have to do this:

```{r shpdf2}

library(sp)
coordinates(cat)<-~X+Y
class(cat)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

The object returned is now a `SpatialPointsDataFrame`.

```{r shpdf3, out.width="60%"}

library(scales) # to use the alpha function for adding transparency

plot(cat,col=alpha(ifelse(cat$Attack==0,"blue","red"),0.4),pch=16,cex=1.5,axes=TRUE)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### From scratch

Shapefiles can also be built from scratch and turned to a spatial object with the `SpatialPointsDataFrame` function.

```{r shpscratch, out.width="50%"}

set.seed(123)
n<-10
x1<-rnorm(n,0,1)
y1<-rnorm(n,0,1)
id<-1:n
x<-SpatialPointsDataFrame(cbind(x1,y1),data=data.frame(id))
head(x)
plot(x,axes=TRUE)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Creating a shapefile of polygons is slightly more complex and requires a couple more steps. 

We will first show the use of pipes ( `%>%` )from the **magrittr** package to make this easier. Pipes are used to apply a series of operations on an object. The first argument of a function in a pipe sequence is by default the result of the previous operation. It is meant to increase the readability of code.

```{r magrittr, tidy=FALSE}

library(magrittr)

temp <- 1:10

sum(rep(mean(temp), 50))

temp %>% 
mean %>% 
rep(50) %>% 
sum

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

To create a polygon, we need to have a matrix of points and in wich the first point is the same as the last to close the polygon.
```{r xscratchpol1, out.width="50%", tidy=FALSE}

m <- rbind(c(0, 0), c(1, 2), c(2, 2), c(3, 2), c(2, 1))
m <- rbind(m, m[1, ])

```

Then we can use pipes to go through the series of steps to build a `SpatialPolygons`. Type `?SpatialPolygons` to better understand the hierarchical structure of polygons.
```{r xscratchpol2, out.width="50%", tidy=FALSE, cache=FALSE}

pol <- m %>% 
     Polygon %>% 
     list %>% 
     Polygons(ID = 1) %>% 
     list %>% 
     SpatialPolygons

plot(pol,axes=TRUE)
length(pol)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## Structure of spatial objects

Spatial objects from the sp package are made with S4 classes. S4 classes are formal classes that can be tricky and hard to understand. Here, I won't go into the details of how S4 classes work, but I will describe the structure of spatial objects.

```{r class, eval=TRUE, cache=FALSE}
library(sp)
getClass("Spatial")

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Indexing

Spatial objects either come with or without attributes. For example, points can be stored in a `SpatialPoints` object or in a `SpatialPointsDataFrame` object. When spatial objects don't have attributes, they behave like vectors and can be indexed as such. 

```{r index1, cache=FALSE}
length(pol)
dim(pol)
pol[1]
```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

When they have attributes, they can be indexed just like a `data.frame`.

```{r index2, cache=FALSE}
length(cat)
dim(cat)
cat[1:3,]
```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Columns of the attribute table can also be extracted just like in a `data.frame`.
```{r S4slots5, cache=FALSE}
cat$Attack
```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Access slots with @

The function `names` and the `$` applied on a spatial object behave the same way as on a `data.frame`, while the `@` operator allows to extract objects stored in the slots of the object. Different methods are also available to extract different information from spatial objects such bounding boxes (`bbox`), centroid coordinates (`coordinates`), etc. Type `?Spatial` to learn more about them.

Names of the columns in the `data.frame` of attributes.
```{r S4names, cache=FALSE}
names(x)
```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Names of the different slots composing the object.
```{r S4slots, cache=FALSE}
slotNames(x)
```

Look at the attribute table which corresponds to a `data.frame`.
```{r S4slots2, cache=FALSE}
head(cat@data)
```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Extract coordinates.
```{r S4slots3, cache=FALSE}
head(cat@coords)
```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Slot containing the bounding box.
```{r S4slots4, cache=FALSE}
cat@bbox
```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## -- Exercice 1 --

Build a `SpatialPointsDataFrame` with 100 random locations centered on Sherbrooke, plot the results and write the results to a shapefile. Hint: use the function `runif` to generate random values within a given range.

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Solution

Here is a solution
```{r ex00, out.width="80%", cache=FALSE}

# Find coordinates using Google maps and generate random values for lat lon coordinates and an id
n<-100
lon<-runif(n,-71.958,-71.822)
lat<-runif(n,45.383,45.433)
id<-1:n

# Build a data.frame and turn it to a SpatialPointsDataFrame
d<-data.frame(lon,lat,id)
coordinates(d)<-~lon+lat

# Plot the result
plot(d,axes=TRUE)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

```{r ex002, out.width="80%", cache=FALSE}
# Write points to a shapefile
writeOGR(d,dsn=".",layer="sherby",driver="ESRI Shapefile", overwrite_layer=TRUE)

# Check if the shapefile has been written
list.files()

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## Spatial operations

Most spatial operations are done using the package `rgeos`. One of the requirement of functions in rgeos is that objects **need to be projected**. When objects are really large, some operations may start to take a long time (e.g. intersections with `gIntersection`).

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Overlay

The function over from package sp is used to determine whether different entities overlap. It returns a vector or a data.frame with the identities or the characteristics of overlapping elements.

```{r overlay1, fig.width=7,fig.height=4,out.width="100%"}
b<-gUnion(x,pol)

xlim<-bbox(b)[1,]
ylim<-bbox(b)[2,]

plot(x,axes=TRUE,xlim=xlim,ylim=ylim)
plot(pol,add=TRUE)

class(x)
class(pol)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

As can be seen in the help files for `?over`, if the second object is a spatial object without attributes, a vector with the same length as the first element is returned with the first overlapping id in the second element.If the second element has attribute data, attribute data are returned.

```{r overlay2, fig.width=7,fig.height=4,out.width="100%"}

# Returns the
o<-over(x,pol)
o

plot(x[!is.na(o),],add=TRUE,col="red")

# Returns the
o<-over(pol,x)
o


```

### Cut or delimit

Here are some common operations that can be done on points (but also on lines or on polygons).

```{r points_op, fig.width=7,fig.height=4,out.width="100%"}
library(rgeos)

op<-c("gCentroid","gEnvelope","gConvexHull","gBuffer","gDelaunayTriangulation")
par(mfrow=c(2,3),mar=c(0,0,3,0))
for(i in seq_along(op)){
  plot(x,main=op[i],xlim=c(-2,2),ylim=c(-3,3))
  plot(get(op[i])(x),col=gray(0.5,0.5),add=TRUE,pch=16,cex=3)
}

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Here are some common operations that are done on polygons.

```{r polygons_op, fig.width=7, fig.height=4,out.width="100%"}

x1<-gBuffer(x[1,],width=1)
x2<-gBuffer(x[2,],width=1)

op<-c("gIntersection","gDifference","gSymdifference","gUnion")
par(mfrow=c(2,2),mar=c(0,0,3,0))
for(i in seq_along(op)){
  plot(x1,main=op[i],xlim=c(-2,2),ylim=c(-3,3))
  plot(x2,add=TRUE)
  plot(get(op[i])(x1,x2),add=TRUE,col="red")
}

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Measure distances

Here, let's measure the distance between each points and their centroid.
```{r measure_distance, out.width="100%"}

cx<-gCentroid(x)
plot(x,axes=TRUE)
plot(cx,add=TRUE,col="red",lwd=3)
text(x,label=round(gDistance(x,cx,byid=TRUE),2),adj=c(0,1.3),cex=0.8)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Measure areas

Here, let's calculate the area of each polygon of a Delaunay triangulation. Also, let's use the `polygonsLabel` function from rgeos to plot the values in a good location in each polygon.
```{r measure_area, fig.width=7,fig.height=5,out.width="100%"}

ch<-gDelaunayTriangulation(x)
area<-gArea(ch,byid=TRUE)
plot(ch,axes=TRUE)
polygonsLabel(ch,labels=round(area,2),cex=0.6,gridpoints=1000,method="centroid")

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Sample

Sample points in polygons in different ways using the `spsample` function.

```{r sample, fig.width=7,fig.height=5,out.width="70%"}

set.seed(12345)

n<-50
type<-c("random","stratified","regular","hexagonal")
par(mfrow=c(2,2),mar=c(0,0,2,0))
for(i in seq_along(type)){
  s<-spsample(pol,n,type=type[i])  
  plot(pol,main=type[i],font=2)
  plot(s,pch=1,add=TRUE)
}

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Random points can also be distributed within random polygons
```{r sample2, fig.width=7,fig.height=5,out.width="70%"}

set.seed(12345)

N<-10 # number of random polygons
n<-5 # number of random points within each polygons

plot(pol)
s1<-gBuffer(spsample(pol,N,type="random"),byid=TRUE,width=0.1)
plot(s1,add=TRUE)
s2<-sapply(s1@polygons,spsample,n=n,type="random")
s2<-do.call("rbind",s2)
plot(s2,add=TRUE)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Combine operations

Here we combine an over with intersections, lengths, buffers, etc.

```{r over, fig.width=8,fig.height=7,out.width="60%",echo=TRUE}
library(scales)
library(TeachingDemos)
b<-gEnvelope(roads)
set.seed(1234)
s<-spsample(b,n=10,type="random")
buffs<-gBuffer(s,width=10000,byid=TRUE)
plot(b)
plot(roads,add=TRUE,col=gray(0.7))
plot(s,add=TRUE)
plot(buffs,add=TRUE,border=NA,col=gray(0,0.1))
```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Let's determine which buffer touch any road.

```{r over2, fig.width=8,fig.height=7,out.width="60%",echo=-(1:10)}
<<over>>
o<-over(buffs,roads)
plot(buffs[apply(o,1,function(i){!all(is.na(i))}),],col=alpha("darkgreen",0.3),border=NA,lwd=2,add=TRUE)
```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Extract sections of road that intersect with a buffer.

```{r over3, fig.width=8,fig.height=7,out.width="60%",echo=-(1:12)}
<<over2>>
int<-gIntersection(buffs,roads,byid=TRUE)
plot(int,col="red",lwd=4,add=TRUE)
```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Finally, calculate the total lengths of roads inside every buffer.

```{r over4, fig.width=8,fig.height=7,out.width="60%",echo=-(1:14)}
<<over3>>
o<-over(buffs,int,returnList=TRUE)
dist<-sapply(o,function(i){
  sum(gLength(int[i],byid=TRUE))  
})
shadowtext(coordinates(buffs),labels=round(dist/1000,1),col="black",bg="white",adj=c(-1,-2))
```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Simplify things

```{r simplify, out.width="50%"}

n<-50
x<-rnorm(n)
y<-rnorm(n)
poly<-gBuffer(SpatialPoints(cbind(x,y)),width=0.5)
plot(poly)
plot(gSimplify(poly,tol=0.6,topologyPreserve=TRUE),border="red",add=TRUE)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

```{r temp, out.width="50%",eval=FALSE, echo=FALSE}

library(rgbif)

p<-occ_search(scientificName="Phragmites australis",limit=3000,hasCoordinate=TRUE,country="CA")
p<-data.frame(p$data)
p$stateProvince<-as.factor(p$stateProvince)
coordinates(p)<-~decimalLongitude+decimalLatitude
class(p)
plot(p,axes=TRUE)

```

<!-- ### Rotate or MST -->

<!-- ## Plotting -->

<!-- ### plot -->

```{r plot, out.width="50%", eval=FALSE, echo=FALSE}

par(mar=c(0,0,0,0))
plot(ch,border="red",col="blue",lwd=10)

```

<!-- ### spplot -->

<!-- Do an spplot on something -->
```{r spplot, out.width="80%", eval=FALSE, echo=FALSE}



```

## -- Exercice 2 --

Calculate the proportion of forest in 10 random buffers across a landscape. Let's first generate the landscape.

```{r ex0, tidy=FALSE}

set.seed(123)

x<-runif(100, 0, 100)
y<-runif(100, 0, 100)

h <- cbind(x, y) %>% 
     SpatialPoints %>% 
     gBuffer(width = rpois(length(x), 4), byid = TRUE) %>% 
     gEnvelope(byid = TRUE) %>% 
     gUnaryUnion
     

plot(h, col = "green4", border = NA, axes = TRUE)

```

Here is a solution.
```{r ex0sol, echo=TRUE, tidy=FALSE}

# First throw 10 random points within the envelope of the landscape and then generates buffers around these points
b<-h %>% 
   gEnvelope %>% 
   spsample(10, type = "random") %>% 
   gBuffer(width = 10, byid = TRUE)

# Plot the buffers
plot(h, col = "green4", border = NA, axes = TRUE)
plot(b, add = TRUE)

# Intersect the buffers with the forest and plot the result
int<-gIntersection(b, h, byid = TRUE)
plot(int, add = TRUE, col = "red", border = NA)

# Compute the proportion of forested areas within each buffer
pa <- gArea(int, byid = TRUE) / gArea(b, byid = TRUE)

# Add the value on the plot
text(coordinates(b), label = round(pa, 2))

```


# PROJECTIONS

As always, when playing with spatial data, one needs to be aware of projections. Assigning and transforming projections in R is not too difficult. It is mostly done with the `proj4string` and `spTransform` functions from **rgdal** package. 

```{r proj_data, fig.width=6.5,fig.height=4,out.width="70%"}

library(rgbif)

x<-occ_search(scientificName="Phragmites australis",limit=3000,hasCoordinate=TRUE,country="CA")
x<-as.data.frame(x$data)
coordinates(x)<-~decimalLongitude+decimalLatitude
plot(x)

```


<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## Assign a projection

```{r proj_assign}

proj4string(x)
proj4string(x)<-CRS("+proj=longlat +datum=WGS84 +ellps=WGS84")
proj4string(x)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## Change a projection

```{r proj_change, fig.width=10, fig.height=6}

#canada<-readOGR("C:/Users/rouf1703/Documents/UdeS/Formation/Canada",layer="Canada")
library(raster)

canada<-getData('GADM', country='CAN', level=1)
proj4string(canada)

crs<-c("+proj=longlat +datum=WGS84 +ellps=WGS84",
       "+proj=utm +zone=18 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0",
       "+proj=utm +zone=10 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0",
       "+proj=laea +lat_0=34 +lon_0=-10 +ellps=GRS80")

par(mfrow=c(2,2),mar=c(2,3,2,0))

for(i in 1:length(crs)){
  canada2<-spTransform(canada,CRS(crs[i]))
  x2<-spTransform(x,CRS(crs[i]))
  plot(canada2,axes=TRUE,main=crs[i],cex.main=0.7)
  plot(x2,add=TRUE) 
  
}


```


<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## Projections and EPSG

Projections can also be given with their epsg number. More info on projections can be found here [epsg.io](http://epsg.io/) where a description of the different epsg is available.

```{r proj_epsg}

x<-spTransform(x,CRS("+init=epsg:4326"))
proj4string(x)

```

All functions from package rgeos require that spatial objects are projected. Otherwise, functions do not work or assume that calculations are done on cartesian coordinates and return a warning message.  

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

# -- Exercice 2 --

Generate a set of 50 200km random buffers across Canada and measure the level of overlap between these buffers.

```{r exA, eval=FALSE}

can<-raster::getData('GADM',country='CAN',level=1)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## SOLUTION

```{r exAsol, out.width="60%", echo=TRUE, include=TRUE}

# first set seed
set.seed(123)

# get shapefile for Canada
can<-raster::getData('GADM',country='CAN',level=1)
can<-spTransform(can,CRS("+proj=laea +lat_0=60 +lon_0=-100 +ellps=GRS80"))
plot(can,border=gray(0.25))

# throw random points
n<-50
p<-spsample(can,n,type="random")

# get buffers
b<-gBuffer(p,width=200*1000,byid=TRUE)
b<-SpatialPolygonsDataFrame(b,data.frame(id=1:n))
plot(b,add=TRUE)
text(coordinates(b),label=b$id)

# build a data.frame to store values
e<-expand.grid(b$id,b$id)

# compute the percent of overlap between each pair
o<-sapply(1:nrow(e),function(i){
  x1<-b[b$id==e[i,1],]
  x2<-b[b$id==e[i,2],]
  g<-gIntersection(x1,x2)
  if(is.null(g)){
    0
  }else{
    gArea(g)/gArea(x1)
  }
  #  
})
e$o<-o

# plot results
plot(e[,1],e[,2],cex=2*e$o,xlab="id 1",ylab="id 2")

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

# RASTERS

## What is a raster?

A raster is a regular grid of pixel with values. Here is an example of building a simple raster with random values.
```{r buildrastersimple}
library(raster)

n<-200
r<-raster(nrow=n,ncol=n,ext=extent(canada))
r<-setValues(r,runif(n^2))
proj4string(r)<-proj4string(canada)
ncell(r)
plot(r)
plot(canada,add=TRUE)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Here is an example of building a raster where each pixel value is determined by the number of points in each cell.
```{r buildrastercomplex}

x<-occ_search(scientificName="Catharus bicknelli",limit=5000,hasCoordinate=TRUE,country="CA")
x<-as.data.frame(x$data)
coordinates(x)<-~decimalLongitude+decimalLatitude
proj4string(x)<-CRS("+init=epsg:4326")
x<-spTransform(x,CRS(proj4string(r)))

r<-rasterize(x,r,field=1,fun="count",background=0)

r<-crop(r,extent(x)) # crop the raster to the extrent of the data
r[r==0]<-NA # do not show empty cells to better visualize abundance of records

plot(canada,col="white",border=gray(0.7),xlim=unname(bbox(x)[1,]),ylim=unname(bbox(x)[2,]),bg=gray(0.7),axes=TRUE)
plot(r,col=rev(heat.colors(100)),add=TRUE)
box()


```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

<!-- ## Raster formats -->

<!-- Rasters can be held in memory or on disk when they are too big. -->

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## Read, write, merge, crop

```{r read_rast, out.width="70%"}

r1<-raster("C:/Users/rouf1703/Documents/UdeS/GitHub/spatialR/data/cdem_dem_021E.tif")
r2<-raster("C:/Users/rouf1703/Documents/UdeS/GitHub/spatialR/data/cdem_dem_031H.tif")

par(mfrow=1:2)
plot(r1)
plot(r2)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Rasters can be aggregated and merged.
```{r merge, out.width="70%"}

ncell(r1)

r1<-aggregate(r1,10)
r2<-aggregate(r2,10)

ncell(r1)

r<-merge(r1,r2)
plot(r)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

Rasters can be cropped with a specific region using the `extent` argument.
```{r crop, out.width="70%"}

e <- extent(-72.75, -70.25, 45, 46)
r <- crop(r, e)
plot(r)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## Layers, Stacks and Bricks

Rasters can have a single layers (`RasterLayer`) or multiple layers (`RasterStack`, `RasterBrick`)

```{r stack1}

r

```

```{r stack2}

temp<-raster::getData('worldclim',var='tmean',res=10)
temp
plot(temp)

```


```{r brick}

temp<-brick(temp)
temp<-stack(temp)

```


<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## Raster operations

### Extract

```{r extract}

e<-extract(r,x)
hist(e,xlab="Altitude",main="")

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

#### Speeding things up with `velox`

```{r velox}
library(velox)
library(microbenchmark)

rv<-velox(r)

buff<-gBuffer(x,byid=TRUE,width=0.05)
plot(r)
plot(buff,add=TRUE)

system.time(extract(r,buff,fun=mean))
system.time(rv$extract(buff,fun=mean))

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Reclassify

```{r reclassify}

mn<-c(0,100,200,400,600,800)
mx<-c(100,200,400,600,800,1200)
mat<-cbind(mn,mx,lab=mx)
mat
rc<-reclassify(r,mat)
plot(rc,col=terrain.colors(nrow(mat)))

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Build a rasters from distances

Measure distances from roads and store the values in a raster.

```{r measure_raster, out.width="60%"}

library(RColorBrewer)
library(FRutils)

roads2<-spTransform(roads,CRS("+proj=utm +zone=18 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0"))
rast<-raster(ncol=200,nrow=200,ext=extent(roads2))
rast_centroids<-xyFromCell(rast,1:ncell(rast),spatial=TRUE)
g<-gDistance(rast_centroids,gLineMerge(roads2),byid=TRUE)

class(g)
dim(g)

rast<-setValues(rast,g[1,])
val<-pretty(seq(min(minValue(rast)),max(maxValue(rast)),length.out=100),10)

lab<-list(at=val,labels=val)
plot(rast,col=colo.scale(1:99,rev(brewer.pal(9,"YlOrRd"))),breaks=99,axis.args=lab)
plot(roads2,add=TRUE)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Rasterize

An example on using rasterize to compute the length of roads within each pixel of a raster.

```{r road_density, out.width="60%"}

test<-rasterize(roads2,aggregate(rast,10),fun="length")
plot(test)
plot(roads2,add=TRUE)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Random walk

An example of extracting the distance to a road for each location of a random walk

```{r rw, out.width="60%"}

set.seed(123)

n<-1000
e<-extent(rast)

x<-c(extent(rast)[1])+cumsum(rnorm(n,0,2000)+500)
y<-c(extent(rast)[3])+cumsum(rnorm(n,0,2000)+500)

l<-Line(cbind(x,y)) %>% 
  list %>% 
  Lines(ID = 1) %>% 
  list %>% 
  SpatialLines

plot(rast,col=colo.scale(1:99,rev(brewer.pal(9,"YlOrRd"))),breaks=99,axis.args=lab)
plot(roads2,add=TRUE)
plot(l,add=TRUE,col="blue",lwd=2)

e<-extract(rast,l)

hist(e[[1]])


```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Contours

Convert rasters values to contours in a SpatialLines object.

```{r raster2cont, out.width="70%"}

con<-rasterToContour(rast)
con
plot(rast)
plot(con,add=TRUE)

```

### Rasterizing a polygon

```{r rasterizepol, out.width="70%"}

pr<-rasterize(buff,r)
pr
plot(pr)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### Polygonizing a raster

```{r polygonize}

pr<-rasterToPolygons(r,fun=function(x){x>700},dissolve=TRUE)
plot(r)
plot(pr,col="red",border=NA,add=TRUE)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

<!-- ## Plotting with `rasterVis` -->

<!-- ## `SpatialGrids` and `SpatialPixels` -->

<!-- ## Grids -->

<!-- ## Pixels -->

# -- Exercice 2 --

Get data for *Trillium cernuum* using package `rgbif` and calculate the mean annual temperature and annual precipitation in the species range. [Bioclimatic variables](http://worldclim.org/bioclim) are described in the WorldClim pages.

Here is how to download the data.
```{r ex2, eval=FALSE}

# download temperature data
r<-raster::getData('worldclim',var='bio',res=2.5,lon=-70,lat=65)

# download records
x<-occ_search(scientificName="Trillium erectum",limit=1000,hasCoordinate=TRUE,country="CA")

# the object returned is a gbif object and we need to extract the tibble in the data element and turn it into a data.frame x
x<-as.data.frame(x$data)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## SOLUTION

```{r ex2sol, out.width="100%", dev.args=list(pointsize=9), echo=TRUE, include=TRUE}

# dowload climatic data
r<-raster::getData('worldclim',var='bio',res=10)
r<-subset(r,c(1,12))
names(r)<-c("temp","prec")

# download Trillium data
x<-occ_search(scientificName="Trillium cernuum",limit=1000,hasCoordinate=TRUE,country="CA")

# get the records in a spatial object
x<-as.data.frame(x$data)
coordinates(x)<-~decimalLongitude+decimalLatitude

# use the same projection for both object
proj4string(x)<-CRS("+init=epsg:4326")
x<-spTransform(x,CRS(proj4string(r)))

# reduce raster size to the bounding box of the records
r<-crop(r,extent(x))

# get convex hull of distribution
a<-gConvexHull(x)

# check data
par(mfrow=c(2,1),mar=c(2,3,1,3))
plot(r[[1]])
plot(x,add=TRUE)
plot(a,add=TRUE)
plot(r[[2]])
plot(x,add=TRUE)
plot(a,add=TRUE)

# extract values within the range of the species
e<-extract(r,a)

# check distribution of values for mean annual temperature and precipitation
par(mfrow=c(1,2))
hist(e[[1]][,1]/10,xlab="")
hist(e[[1]][,2],xlab="")

```


# MAPPING

## STATIC

### `plot`

```{r map_plot, out.width="70%", dev.args=list(pointsize=9)}

data(meuse)
coordinates(meuse)<-~x+y
proj4string(meuse) <- CRS("+init=epsg:28992")
head(meuse)
plot(meuse)

```

### `spplot`

```{r spplot_map, out.width="70%", dev.args=list(pointsize=9)}

spplot(meuse,z=c("cadmium","copper","lead","zinc"))

```

### `levelplot`

```{r levelplot, out.width="70%", dev.args=list(pointsize=9)}

library(rasterVis)

r<-raster::getData('worldclim',var='tmean',res=10)
r<-crop(r,extent(-73,-70,45,48))

levelplot(r/10,col.regions=rasterTheme()$regions$col,cuts=99)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### `ggspatial`

```{r ggspatial_map, out.width="70%", dev.args=list(pointsize=9)}

library(ggspatial)

ggspatial(meuse)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### `OpenStreetMap`

```{r OSM}
library(dismo)

test<-gmap(meuse,type="roadmap",filename="map.gmap",scale=2)
p<-spTransform(meuse,CRS(proj4string(test)))
test<-crop(test,p)
plot(test)
plot(p,add=TRUE)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### `ggmap`

```{r ggmap}
library(ggmap)

test<-gmap("Sherbrooke",type="satellite",scale=2,zoom=13,rgb=FALSE)
plot(test)

qmap("Sherbrooke",zoom=14,maptype="satellite")

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## INTERACTIVE

### Drawing polygons

select, drawPoly from package raster to interactively select elements

```{r drawPoly}

plot(x)
#pol<-drawPoly()
#plot(pol,add=TRUE,col="red")


```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>



### `leaflet`

Here present leaflet and leafletExtras

```{r leaflet1, tidy=FALSE, message=TRUE, warning=TRUE}

library(leaflet)
library(leaflet.extras)

leaflet(cat) %>% 
  addTiles() %>%
  addCircleMarkers(data = cat, group = 'cat') %>%
  addDrawToolbar(targetGroup = 'cat', editOptions = editToolbarOptions(selectedPathOptions = selectedPathOptions())) %>%
  addLayersControl(overlayGroups = c('cat'),options =layersControlOptions(collapsed=FALSE)) %>%
  addMeasurePathToolbar(options =measurePathOptions(imperial = TRUE,minPixelDistance = 100,showDistances = FALSE))


```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### `tmap` 

```{r tmap, out.width="100%"}

cat$attack<-as.factor(cat$Attack)

library(tmap)

tmap_mode("view")

tm_shape(roads)+
  tm_lines()+
  tm_shape(cat)+
  tm_dots("attack")+
  tm_layout(basemaps=c("Esri.WorldImagery","Esri.WorldShadedRelief","Esri.NatGeoWorldMap"))

```



<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

### `mapedit`

Here is a test with using [mapedit](http://r-spatial.org/r/2017/06/09/mapedit_0-2-0.html) functionality.

```{r mapedit, eval=FALSE}

library(mapview)
library(mapedit)

x <- mapview() %>% editMap()
plot(x)
#x <- as(x[[1]],"Spatial")
plot(x)

```

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

<!-- # -- EXERCICE 3  -->

<!-- Generate random home ranges in a region and measure percent overlap between them. -->

<!-- ## SOLUTION  -->

```{r exercices3hr, eval=FALSE}



```
# MORE POSSIBILITIES

The main book for learning to use R for spatial data is probably [Applied Spatial Data Analysis with R](http://www.asdar-book.org/) by Bivand et al. (2013)

| Package | Use |
| :-------------:|:----------------------------------------|
| **spatstat** | Huge package mainly for analysing spatial point patterns | 
| **adehabitat** | A collection of packages for studying habitat selection |
| **gstat** | Variograms, geostatistics, kriging, etc. | 
| **SDMTools** | Tools for Species Distribution Modeling | 
| **spdep** | Tools for studying spatial dependence |

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## Spatial Task View

The [Spatial Task View]() on maintained on CRAN is worth a visit if you are searching for more possibilities.

## rspatial.org

A good online reference for doing spatial analyses with R is [rspatial.org](rspatial.org) which provides lots of examples on diferent types of analyses.

<!--![rspatial.org](C:/Users/rouf1703/Documents/UdeS/GitHub/spatialR/rspatial.png)--> 

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

## Special packages

### Landscape metrics with `SDMTools` or `spatialEco`

```{r metrics1}

library(SDMTools)
library(spatialEco)


r <- raster(nrows=200, ncols=200, xmn=0, xmx=100, ymn=0, ymx=100)

x<-runif(100,0,100)
y<-runif(100,0,100)

h<-gUnaryUnion(gEnvelope(gBuffer(SpatialPoints(cbind(x,y)),width=rpois(length(x),4),byid=TRUE),byid=TRUE))

r<-rasterize(h,r)

plot(r,col="green4")

x <- sampleRandom(r,1, na.rm = TRUE, sp = TRUE)
pol<-SpatialPolygonsDataFrame(gBuffer(x,width=20),data.frame(id=1),match.ID=FALSE)

a<-land.metrics(x=pol,y=r,metrics = c(2:38))

plot(pol,add=TRUE)
#plot(rasterToPolygons(r),add=TRUE)
plot(x,add=TRUE)

Scalebar(x=90,y=3,distance=20,unit='m',scale=1)

a
```

<!-- ### Spatial statistics with `spatstat` -->

<!-- ### Spatial dependence with `spdep` -->

<!-- Show an example of computing Moran's I on a SpatialPolygons of ecodistricts. -->

<!-- ### Kriging with `gstat` -->

<!-- library(gstat) -->

<!-- v <- variogram(elev~1,data=eco2,cutoff=2500000,width=10000) # calculates sample variogram values  -->
<!-- plot(v) -->
<!-- vfit <- fit.variogram(v, model=vgm("Sph")) # fit model -->

<!-- plot(v,vfit) -->

<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>

<!-- ### kriging -->

```{r spatialcorr, eval=FALSE, echo=FALSE}

library(foreign)

url<-"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/district/ecodistrict_shp.zip"
path<-getwd()
#download.file(url,destfile=paste(path,"eco.zip",sep="/"))
#unzip(paste(path,"eco.zip",sep="/"))
eco<-readOGR(paste(path,"Ecodistricts",sep="/"),"ecodistricts")
eco<-spTransform(eco,CRS("+proj=laea +lat_0=55 +lon_0=-100 +ellps=GRS80"))

eco$lon<-coordinates(eco)[,1]
eco$lat<-coordinates(eco)[,2]

#url<-"http://ftp.geogratis.gc.ca/pub/nrcan_rncan/archive/vector/ecosystems/ecodistrict/ecodist.shp.zip"
#path<-"C:/Users/rouf1703/Documents/temp"
#path<-getwd()
#download.file(url,destfile=paste(path,"eco2.zip",sep="/"))
#unzip(paste(path,"eco2.zip",sep="/"))
#eco<-readOGR(paste(path,sep="/"),"ECODIST")


#download.file("http://sis.agr.gc.ca/cansis/nsdb/ecostrat/district/dt_temp.dbf",destfile=paste(path,"dt_temp.dbf",sep="/"))
temp<-read.dbf(paste(path,"dt_temp.dbf",sep="/"))

#download.file("http://sis.agr.gc.ca/cansis/nsdb/ecostrat/district/dt_elevation.dbf",destfile=paste(path,"dt_elevation.dbf",sep="/"))
elev<-read.dbf(paste(path,"dt_elevation.dbf",sep="/"))

eco$elev<-elev$MEAN_ELEV[match(eco$ECODISTRIC,elev$DISTRICT)]
#eco$elev[eco$elev<(-50)]<-NA

eco$temp<-temp$TMEAN_ANN[match(eco$ECODISTRIC,temp$DISTRICT)]
eco$temp[eco$temp<(-50)]<-NA

eco<-eco[!is.na(eco$elev) & !is.na(eco$temp),]
# eco$temp<-sample(eco$temp)
eco2<-eco[sample(1:nrow(eco),floor(nrow(eco)/5)),]

library(gstat)

v <- variogram(elev~1,data=eco2,cutoff=2500000,width=10000) # calculates sample variogram values 
plot(v)
vfit <- fit.variogram(v, model=vgm("Sph")) # fit model

plot(v,vfit)

### kriging

r<-raster(eco,ext=extent(eco),ncol=200,nrow=200)

P<-SpatialPointsDataFrame(SpatialPoints(coordinates(r),proj4string=CRS(proj4string(eco))),data.frame(id=1:ncell(r)))
o<-as.logical(sapply(over(P,eco,returnList=TRUE),nrow))
p<-P[o,]
k<-krige(elev~1,eco2,p,model=vfit)

P$val<-rep(NA,nrow(P))
P$val[o]<-k@data[,1]

r<-setValues(r,P$val)
plot(P,col=colo.scale(P$val),pch=16)

par(mfrow=c(1,2))
plot(r,col=rev(colo.scale(1:100,rev(c("darkred","yellow","green","blue","violet")))))
plot(eco,col=colo.scale(eco$elev,c("darkred","yellow","green","blue","violet")))

par(mfrow=c(1,2),mar=c(0,0,0,0))
plot(r,col=colo.scale(1:100,c("brown","orange","lightgoldenrod","green","darkgreen")),box=FALSE)
plot(eco,col=colo.scale(eco$elev,c("brown","orange","lightgoldenrod","green","darkgreen")),border=NA)



#par(mfrow=c(1,2))
#plot(r,col=rev(colo.scale(1:100,rev(c("darkred","yellow","green","blue","violet")))))
#plot(eco,col=colo.scale(eco$elev,c("darkred","yellow","green","blue","violet")))

par(mfrow=c(1,2),mar=c(0,0,0,0))
plot(r,col=colo.scale(1:100,c("brown","orange","lightgoldenrod","green","darkgreen")),box=FALSE)
plot(eco,col=colo.scale(eco$elev,c("brown","orange","lightgoldenrod","green","darkgreen")),border=NA)

```

<!-- ### Animal movements with `adehabitat` and `trip` -->

<!-- ### Spatial Autocorrelation -->

```{r SA, eval=FALSE, echo=FALSE}

library(spdep)

#neighbours <- poly2nb(cat)


```

<!-- ### Kernel smoothing with `ks` -->

<!-- ### Great circles with `geosphere` -->

<!-- ## Extensions -->

<!-- ### RQGIS -->

<!-- ### RpostGIS -->

<!-- ### RGRASS -->

# `sf`: SIMPLE FEATURES FOR R

[Vignette 1](https://cran.r-project.org/web/packages/sf/vignettes/sf1.html)

- S3 class
- Interacts with the tidyverse and dplyr
- Easy conversion from **sp** to **sf**






