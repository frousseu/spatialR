---
title: "Introduction to spatial tasks with R"
author: "Francois Rousseu"
date: '2017-07-17'
output:
  html_document:
    depth: 4
    fig_height: 5
    fig_width: 6
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: no
  html_notebook:
    number_sections: no
    toc: yes
    toc_depth: 4
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: 4
geometry: left=2cm,right=2cm,top=3cm,bottom=2.5cm
---

<script>
   $(document).ready(function() {
     $head = $('#header');
     $head.prepend('<img src=\"cef.gif\" style=\"float: right;width: 75px;\"/>')
   });
</script>

<style>
pre.r {
    background-color: #CCCCCC !important;
}
</style>

<style>
  .main-container {
    max-width: 1300px !important;
  }
</style>

```{r options, include=TRUE, cache=FALSE, echo=FALSE, message=FALSE}
options(width=80)
knitr::opts_chunk$set(cache=TRUE,comment="##",echo=TRUE,message=FALSE,warning=FALSE,tidy=TRUE,size="small",fig.align="center",out.width="100%")

```

# INTRODUCTION

The main book for learning to use R for spatial data is probably [Applied Spatial Data Analysis with R](http://www.asdar-book.org/) by Bivand et al. (2013)

## Packages

## Polygons

## `sp` vs. `sf` ?
  
# SHAPEFILES



## From a `data.frame`

Let's load some data that contains locations of Jaguars attacks in the kalakmul reserve in Mexico. Interviews were done with farmers about whether attacks from jaguars (or cougars) happened with their cattle. 

```{r shpdf1}

cat<-read.table("C:/Users/rouf1703/Documents/UdeS/Consultation/M-LLecuyer/Doc/cat.txt",header=TRUE,stringsAsFactors=FALSE)
#write.table(cat[,c("X","Y","Attack")],"C:/Users/rouf1703/Documents/UdeS/Consultation/M-LLecuyer/Doc/cat.txt",row.names=FALSE)
head(cat)

```

This is a simple data.frame with X and Y columns representing longitudes and latitudes. To transform this data.frame to a spatial object, we just have to do this:
```{r shpdf2}

coordinates(cat)<-~X+Y
class(cat)

```

The object returned is now a `SpatialPointsDataFrame`. This object can be simply plotted with the function plot which has a method for Spatial objects.

```{r shpdf3, out.width="70%"}

plot(cat,axes=TRUE, xlab="Longitude", ylab="Latitude")

```


## Reading and writing

### Reading

Reading shapefiles is done with the function `readOGR` from the `rgdal` package.

```{r read}

library(rgdal)
roads<-readOGR(dsn="C:/Users/rouf1703/Documents/UdeS/Consultation/M-LLecuyer/Doc",layer="roads",verbose=FALSE,encoding="UTF-8")
pop<-readOGR(dsn="C:/Users/rouf1703/Documents/UdeS/Consultation/M-LLecuyer/Doc",layer="pop",verbose=FALSE,encoding="UTF-8")

class(roads)

```


```{r read2, out.width="70%"}

plot(roads,col=gray(0.75),lwd=4, axes=TRUE)
plot(pop,add=TRUE,cex=1+10*pop$POBTOT/max(pop$POBTOT),col=alpha("green4",0.25),pch=15)
plot(cat,add=TRUE,col=alpha(ifelse(cat$Attack==0,"blue","red"),0.4),pch=16,cex=1.5)

```


### Writing

```{r write, eval=FALSE}

writeOGR(cat,dsn="C:/Users/rouf1703/Documents/UdeS/Consultation/M-LLecuyer/Doc",layer="cat",driver="ESRI Shapefile")

```


## Building shapefiles

### From scratch

```{r shpscratch}

set.seed(123)
n<-10
x1<-rnorm(n,0,1)
y1<-rnorm(n,0,1)
id<-1:n
x<-SpatialPointsDataFrame(cbind(x1,y1),data=data.frame(id))
head(x)
plot(x,axes=TRUE)

```

To close a polygon, the last point of the matrix needs to be the first point that starts the polygon.
```{r xscratchpol}

library(magrittr)

m<-rbind(c(1,1),c(1,2),c(2,2),c(3,2),c(2,1))

z<-rbind(m, m[1, ]) %>% 
  Polygon %>% 
  list %>% 
  Polygons(ID = 1) %>% 
  list %>% 
  SpatialPolygons

plot(z,axes=TRUE)

```


## Accessing data with S4 class

### The `Spatial` class with `sp`

```{r class}

library(sp)
getClass("Spatial")

```

## Spatial operations

Most spatial operation are done using the package `rgeos`. One of the requirement of the functions is that objects should be projected. When objects are really large, some operation may start to take a long time (e.g. intersections).

### Cut or delimit things

Here are some common operations that can be done on points (but also lines or polygons.

```{r points_op, fig.width=7,fig.height=4,out.width="100%"}
library(rgeos)

op<-c("gCentroid","gEnvelope","gConvexHull","gBuffer","gDelaunayTriangulation")
par(mfrow=c(2,3),mar=c(0,0,3,0))
for(i in seq_along(op)){
  plot(x,main=op[i],xlim=c(-2,2),ylim=c(-3,3))
  plot(get(op[i])(x),col=gray(0.5,0.5),add=TRUE,pch=16,cex=3,border=NA)
}

```

Here are some common operations that are done on polygons.

```{r polygons_op, fig.width=7, fig.height=4}

x1<-gBuffer(x[1,],width=1)
x2<-gBuffer(x[2,],width=1)

op<-c("gIntersection","gDifference","gSymdifference","gUnion")
par(mfrow=c(2,2),mar=c(0,0,3,0))
for(i in seq_along(op)){
  plot(x1,main=op[i],xlim=c(-2,2),ylim=c(-3,3))
  plot(x2,add=TRUE)
  plot(get(op[i])(x1,x2),add=TRUE,col="red")
}

```


### Measure things

```{r measure_distance, out.width="60%"}

cx<-gCentroid(x)
plot(x,axes=TRUE)
plot(cx,add=TRUE,col="red",lwd=3)
text(x,round(gDistance(x,cx,byid=TRUE),2),adj=c(0,1.3),cex=0.8)

```


```{r measure_area, fig.width=7,fig.height=5,out.width="100%"}

ch<-gDelaunayTriangulation(x)
area<-gArea(ch,byid=TRUE)
plot(ch,axes=TRUE)
polygonsLabel(ch,labels=round(area,2),cex=0.4,gridpoints=1000)

```

### Sample things

Sample points in polygons in different ways using the `spsample` function.

```{r sample, fig.width=7,fig.height=5,out.width="70%"}

set.seed(123)

n<-50
type<-c("random","stratified","regular","hexagonal")
par(mfrow=c(2,2),mar=c(0,0,2,0))
for(i in seq_along(type)){
  s<-spsample(z,n,type=type[i])  
  plot(z,main=type[i],font=2)
  plot(s,pch=1,add=TRUE)
}

```


### Overlay things

Here we combine an over with Intersection, Length, buffers, etc.

```{r over, fig.width=8,fig.height=7,out.width="60%",echo=TRUE}
library(scales)
library(TeachingDemos)
b<-gEnvelope(roads)
set.seed(1234)
s<-spsample(b,n=10,type="random")
buffs<-gBuffer(s,width=10000,byid=TRUE)
plot(b)
plot(roads,add=TRUE,col=gray(0.7))
plot(s,add=TRUE)
plot(buffs,add=TRUE,border=NA,col=gray(0,0.1))
```

Let's determine which buffer touch any road.

```{r over2, fig.width=8,fig.height=7,out.width="60%",echo=-(1:10)}
<<over>>
o<-over(buffs,roads)
plot(buffs[apply(o,1,function(i){!all(is.na(i))}),],col=alpha("red",0.3),border=NA,lwd=2,add=TRUE)
```

Extract sections of road that intersect with a buffer.

```{r over3, fig.width=8,fig.height=7,out.width="60%",echo=-(1:12)}
<<over2>>
int<-gIntersection(buffs,roads,byid=TRUE)
plot(int,col="red",lwd=4,add=TRUE)
```

Finally, calculate the total lengths of roads inside every buffer.

```{r over4, fig.width=8,fig.height=7,out.width="60%",echo=-(1:14)}
<<over3>>
o<-over(buffs,int,returnList=TRUE)
dist<-sapply(o,function(i){
  sum(gLength(int[i],byid=TRUE))  
})
shadowtext(coordinates(buffs),labels=round(dist/1000,1),col="black",bg="white")
```

### Simplify things

```{r simplify, out.width="50%"}

n<-50
x<-rnorm(n)
y<-rnorm(n)
poly<-gBuffer(SpatialPoints(cbind(x,y)),width=0.5)
plot(poly)
plot(gSimplify(poly,tol=0.6,topologyPreserve=TRUE),border="red",add=TRUE)

```

```{r temp, out.width="50%"}

library(rgbif)

p<-occ_search(scientificName="Phragmites australis",limit=3000,hasCoordinate=TRUE,country="CA")
p<-data.frame(p$data)
p$stateProvince<-as.factor(p$stateProvince)
coordinates(p)<-~decimalLongitude+decimalLatitude
class(p)
plot(p,axes=TRUE)

```

#### spsample, elide, mst

## Plotting

### plot

```{r plot, out.width="50%"}

par(mar=c(0,0,0,0))
plot(ch,border="red",col="blue",lwd=10)

```

### spplot

```{r spplot, out.width="80%"}


```

## S4 objects

### Access slots with @

```{r S4names}
names(p)
```


```{r S4slots}
slotNames(p)
```


```{r S4slots2}
head(p@data)
```

```{r S4slots3}
p@bbox
```

Extractions of elements in spatial objects stored in slots are made either by accessing them using slots (with `@` instead of `$` which access columns in the `data.frame` attribute table stored in `@data`) or more easily with extractor function such as `bbox`, `proj4string` or `coordinates`.

```{r S4slots4}
p$copper
```


## The new package sf

# PROJECTIONS

As always, when playing with spatial data, one needs to be aware of projections. Assigning and transforming projections in R is not to difficult. It is mostly done with the `proj4string` and `spTransform` functions from package **rgdal**. 

```{r proj_data, fig.width=6.5,fig.height=4,out.width="100%"}

library(rgbif)

x<-occ_search(scientificName="Phragmites australis",limit=3000,hasCoordinate=TRUE,country="CA")
x<-as.data.frame(x$data)
coordinates(x)<-~decimalLongitude+decimalLatitude

```

## Assign a projection

```{r proj_assign}

proj4string(x)
proj4string(x)<-CRS("+proj=longlat +datum=WGS84 +ellps=WGS84")
#proj4string(x)<-CRS("+init=epsg:4326")
proj4string(x)

```

## Change a projection

```{r proj_change, fig.width=10, fig.height=6}

canada<-readOGR("C:/Users/rouf1703/Documents/UdeS/Formation/Canada",layer="Canada")
proj4string(canada)

crs<-c("+proj=longlat +datum=WGS84 +ellps=WGS84",
       "+proj=utm +zone=18 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0",
       "+proj=utm +zone=10 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0",
       "+proj=laea +lat_0=34 +lon_0=-10 +ellps=GRS80")

par(mfrow=c(2,2),mar=c(2,3,2,0))

for(i in 1:length(crs)){
  canada2<-spTransform(canada,CRS(crs[i]))
  x2<-spTransform(x,CRS(crs[i]))
  plot(canada2,axes=TRUE,main=crs[i],cex.main=0.7)
  plot(x2,add=TRUE) 
  
}


```

## Projections and EPSG

Projections can also be given with their epsg number. More info on projections can be found here [epsg.io](http://epsg.io/) where a list of the different epsg is available

```{r proj_epsg}

x<-spTransform(x,CRS("+init=epsg:4326"))
proj4string(x)

```

All functions from package rgeos require that Spatial object are projected, other wise, function do not work or assume that calculation are done on cartesian coordinates and returns a warning message.  

# RASTERS

## What is a raster?

A raster is a regular grid of pixel with values. Here is an example of building a simple raster with random values.
```{r buildrastersimple}
library(raster)

n<-50
r<-raster(nrow=50,ncol=50,ext=extent(canada))
r<-setValues(r,runif(n^2))
ncell(r)
plot(r)
plot(canada,add=TRUE)

```

Here is an example of building a raster where each pixel value is determined by the number of points in each cell.
```{r buildrastercomplex}

x<-occ_search(scientificName="Catharus bicknelli",limit=5000,hasCoordinate=TRUE,country="CA")
x<-as.data.frame(x$data)
coordinates(x)<-~decimalLongitude+decimalLatitude
proj4string(x)<-CRS("+init=epsg:4326")


#x<-spTransform(x,CRS(proj4string(canada)))


#x<-rgamma(100000,3)
#y<-rgamma(100000,3)
#s<-SpatialPoints(cbind(x,y))
#r<-raster(nrow=100,ncol=100,ext=extent(s))
#r<-rasterize(s,r,field=1,fun="count",background=0)
r<-rasterize(x,r,field=1,fun="count",background=0)

plot(r,col=rev(heat.colors(100)))
plot(canada,col=gray(0,0.05),border=gray(0,0.01),add=TRUE)
points(x,col=gray(0,0.05))

```

## Raster formats

## Read, write, merge, crop

```{r read_rast}

r1<-raster("C:/Users/rouf1703/Documents/UdeS/Formation/cdem_dem_021E_tif/cdem_dem_021E.tif")
r2<-raster("C:/Users/rouf1703/Documents/UdeS/Formation/cdem_dem_031H_tif/cdem_dem_031H.tif")
par(mfrow=1:2)
plot(r1)
plot(r2)

r1

```


```{r merge}

r1<-aggregate(r1,10)
r2<-aggregate(r2,10)
r<-merge(r1,r2)
plot(r)

```


```{r crop}

e <- extent(-72.75, -70.25, 45, 46)
r <- crop(r, e)
plot(r)

```

## Stacks and Bricks

```{r stack}



```


## Raster operations

### Summarize


```{r summ}

r

```

### Extract

```{r extract}

e<-extract(r,x)
hist(e,xlab="Altitude",main="")

```

### Reclassify

```{r reclassify}

mn<-c(0,100,200,400,600,800)
mx<-c(100,200,400,600,800,1200)
mat<-cbind(mn,mx,lab=mx)
mat
rc<-reclassify(r,mat)
plot(rc,col=terrain.colors(nrow(mat)))

```


### random walk and cost

```{r rw}

n<-1000
e<-extent(r)

```

### Countour and rasterToContours



### Speeding things up with `velox`

```{r velox}
library(velox)
library(microbenchmark)

rv<-velox(r)

buff<-gBuffer(x,byid=TRUE,width=0.05)
plot(r)
plot(buff,add=TRUE)

system.time(extract(r,buff,fun=mean))
system.time(rv$extract(buff,fun=mean))

```

## From shp to raster and back

### Rasterizing a polygon

```{r rasterizepol}

pr<-rasterize(buff,r)
pr
plot(pr)

```

### Polygonizing a raster

## Plotting with `rasterVis`

## `SpatialGrids` and `SpatialPixels`

## Grids

## Pixels

# STATIC MAPPING

## `plot`

```{r }


```

## `levelplot`

```{r }


```

## `spplot`

## `ggplot` and `ggmap`

## `ggspatial`

## chloropleth mapping

# INTERACTIVE MAPPING

select, drawPoly from package raster to interactively select elements

```{r drawPoly}

plot(x)
#pol<-drawPoly()
#plot(pol,add=TRUE,col="red")


```

## `OpenStreetMap`

```{r }
library(dismo)
#library(OpenStreetMap)

test<-gmap(p,type="roadmap",filename="map.gmap",scale=2)
proj4string(p)<-CRS("+init=epsg:4326")

p<-spTransform(p,CRS(proj4string(test)))
test<-crop(test,p)
plot(test)
plot(p,add=TRUE)

```

## `ggmap`

```{r }
library(ggmap)

test<-gmap("Sherbrooke",type="satellite",filename="map.gmap",scale=2,zoom=15,rgb=FALSE)
plot(test)

qmap("Sherbrooke",zoom=15,maptype="satellite")

```

## `leaflet`

```{r }



```

## `tmap` 

```{r }


```

## `mapview`

```{r }


```

## `mapedit`

Here is a test with using mapedit functionality.

```{r mapedit, eval=FALSE}
library(mapview)
library(mapedit)
library(sp)

x <- mapview() %>% editMap()
plot(x)
x <- as(x[[1]],"Spatial")
plot(x)

```

# MORE POSSIBILITIES

## Spatial Task View

## Reference Site: rspatial.org

## Special packages

### Spatial statistics with `spatstat`

### Spatial dependence with `spdep`

### Kriging with `gstat`

### Animal movements with `adehabitat` and `trip`

### Kernel smoothing with `ks`

### Great circles with `geosphere`

## Extensions

### RQGIS

### RpostGIS

### RGRASS

# `sf`: THE NEW SPATIAL

## Why?

### S3 classes

### Tidyverse

### From `sp` to `sf` and back

