---
title: Introduction à la manipulation de données géospatiales avec R
output:
  html_document:
    depth: 4
    fig_height: 4
    fig_width: 6
    number_sections: no
    toc: yes
    toc_depth: 5
    toc_float:
      collapsed: no
      smooth_scroll: no
  beamer_presentation:
    colortheme: lily
    fonttheme: structurebold
    slide_level: 2
    theme: Singapore
    toc: yes
  html_notebook:
    number_sections: no
    toc: yes
    toc_depth: 5
  ioslides_presentation:
    smaller: yes
    transition: faster
    widescreen: yes
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: 4
always_allow_html: yes
editor_options: 
  chunk_output_type: console
---

```{=html}
<script>
    $(document).ready(function() {
      $items = $('div#TOC li');
      $items.each(function(idx) {
        num_ul = $(this).parentsUntil('#TOC').length;
        $(this).css({'text-indent': num_ul * 20, 'padding-left': 0});
      });

    });
</script>
```


```{=html}
<style>

pre.r {
    background-color: #EEEEEE;
    border-color: #EEEEEE;
    font-size: 12pt;
}

pre code {
  font-size: 12pt;
}

body {
  font-size: 14pt;
  margin-right: 5vw;
  margin-left: 0vw;
  /* max-width: 80vw; */
}

.main-container {
    max-width: 100vw !important;
} 

#TOC {
  font-size: 0.75vw;
  border-color: white;
  max-width: 12vw;
  margin-top: 5vh;
}

.list-group-item.active:focus{
    z-index: 2;
    color: darkgreen;
    background-color: #EEEEEE;
    /* font-weight: bolder; */
    text-decoration: underline;
}

.list-group-item.active:hover {
    z-index: 2;
    color: darkgreen;
    background-color: #FFFFFF;
    /* font-weight: bolder; */
    text-decoration: underline;
}

.list-group-item.active{
    z-index: 2;
    color: darkgreen;
    background-color: #FFFFFF;
    /* font-weight: bolder; */
    text-decoration: underline;
}

h1.title {
  margin-top: 50px;
  font-size: 42px;
  color: DarkGreen;
  font-weight: bold;
}

h1, h2, h3, h4, h5, h6 {
  margin-top: 25vh;
  padding-top: 40px;
  padding-bottom: 20px;
  color: DarkGreen;
  font-weight: bold;
}

h1, h2, h3, h4, h5 {
  font-size: 42px;
}

a {
  font-weight: bold;
}

.pres { /* write {.pres} next to each section to apply css  */
   padding-top: 100px;
   margin-bottom: 700px;
}

/* html{
  scroll-behavior: smooth;
} */


</style>
```

 
```{r options, include=TRUE, cache=FALSE, echo=FALSE, message=FALSE, eval=TRUE}
options(width=90)
knitr::opts_chunk$set(cache = TRUE, comment = "##", eval = TRUE, error = TRUE, echo = TRUE, message =FALSE, warning = FALSE, tidy = TRUE, size = "LARGE", fig.align = "center", out.width = "100%")

```

<br>

# INTRODUCTION

The two most important R packages for manipulating spatial objects are:
<br><br>
[sf](https://r-spatial.github.io/sf) <br> 
vectors, points, lines, polygons, shapefiles and geopackages
<br><br>
[terra](https://rspatial.github.io/terra/reference/terra-package.html)<br>
rasters or regularly gridded data
<br><br><br>
You may see some code or package that still rely on the packages **sp**, **rgdal**, **rgeos** or **raster**, but these are now mostly retired and were entirely replaced by **sf** and **terra**.
<br><br>
Another important package is [stars](https://r-spatial.github.io/stars/) for spatiotemporal arrays and  raster and vector data cubes, but we won't talk about this package in this workshop.

<br>

# TODO

- explain st_union
- explain sf, sfc, sgpd st_as_sf, as_sfc
- vect terra and sf
- avoid reprojecting rasters (2 reasons)
- base R pipe |>
- explain st_intersects


# VECTOR DATA (sf)

## Reading

First, let's look in the folder where the shapefile is located.

```{r read1, size="tiny"}

list.files("/home/frousseu/Documents/github/spatialR/data")

```

<br>

Reading shapefiles is done with the function `st_read`. 

```{r read2, size="tiny"}

library(sf)

roads <- st_read("/home/frousseu/Documents/github/spatialR/data/carreteras.shp")

```

## Plot it

This object can be plotted simply with the function `plot` which has a method for sf objects. The `st_geometry` is used to only plot the geometry of the object, but not the attributes.
```{r read3, out.width = "70%"}
plot(st_geometry(roads), axes = TRUE)
```


## What exactly is the object `roads`?

```{r read4, out.width="70%"}
class(roads)
head(roads)
```
<br>
It is mostly a data.frame to which we add a **geometry column**. 

## Almost just a `data.frame`
```{r read5, out.width="70%"}
head(as.data.frame(roads))
```

## Plot a single attribute
```{r read6, out.width="70%"}
plot(roads["CLASIF"], lwd = 4, axes = TRUE)
```

## Plot (all) attributes
```{r read7, out.width="70%"}
plot(roads, lwd = 4, axes = TRUE)
```

## Plotting only the geometry

Often, we only want to plot the geometry to see if everything looks OK. This is done with the `st_geometry` function.
```{r read8, out.width = "70%"}
plot(st_geometry(roads), lwd = 4, axes = TRUE)
```


## Interactive map
Alternatively, you can use the [mapview](https://r-spatial.github.io/mapview/index.html) package for a more interactive plot.
```{r read9, out.width = "100%", out.height = 450}

library(mapview)
mapview(roads)

```


## Writing

We can write in different formats. The geopackage format (.gpkg) is used more and more compared to the .shp format. 
```{r write, eval=TRUE, tidy=TRUE}
# As a shapefile
st_write(roads, dsn = "/home/frousseu/Documents/github/spatialR/data/roads.shp", append = FALSE) # append = FALSE overwrites

# As a geopackage
st_write(roads,dsn = "/home/frousseu/Documents/github/spatialR/data/roads.gpkg", append = FALSE)

list.files("/home/frousseu/Documents/github/spatialR/data")
```

<br>

## Building shapefiles

<!-- Let's load some data that contains locations of Jaguars attacks in the Kalakmul reserve in Mexico. Interviews were done with farmers about whether attacks from jaguars (or cougars) happened with their cattle.  -->

```{r shpdf1}

cat <- read.table("/home/frousseu/Documents/github/spatialR/data/cat.txt", header = TRUE)
head(cat)

```

This is a simple `data.frame` with X and Y columns representing longitudes and latitudes. The column `Attack` contains whether a location was concerned by a jaguar attack or not.

<br>

To transform this `data.frame` to a spatial object, we just have to do:

```{r shpdf2}

cat <- st_as_sf(cat, coords = c("X", "Y"), crs = 4326)

```
The object returned is now an sf `data.frame`. The code `4326` is a special id for the lat/lon WGS84 coordinate reference system (crs).

<br>

## Plot it

Here is what it looks like.
```{r shpdf3, out.width="60%"}

plot(st_geometry(cat), col = adjustcolor(ifelse(cat$Attack == 0, "blue", "red"), 0.4), pch = 16, cex = 1.5, axes = TRUE)

```

## Add the 2 layers in an interactive map

```{r shpdf4, out.width="60%"}

mapview(roads) + mapview(cat)

```



## -- Exercice 1 --

Build a spatial `data.frame` with 100 random locations centered on the CEF conference, plot the results with R and `mapview` and write the results to a shapefile or a geopackage (.gpkg). Read the shapefile you wrote to make sure everything worked well. 

Hint: use the function `runif` or `rnorm` to generate random values within a given range. For example:

<br>

```{r ex1, eval = FALSE}

lat <- rnorm(100, mean = 45, sd = 0.1) # 100 random values with a mean of 45 and an sd of 0.1
lon <- rnorm(100, mean = 72, sd = 0.1) 

```


### -- Solution --

Here is a solution
```{r ex00, out.width="70%", echo=FALSE, include=FALSE}

# Find coordinates using Google maps and generate random values for lat lon coordinates and an id
set.seed(1234) # set the random seed to get reproducible results
n <- 50
lon <- rnorm(n,-75.7386, 0.04)
lat <- rnorm(n, 45.4221, 0.04)
id <- 1:n

# Build a data.frame and turn it to a SpatialPointsDataFrame
x <- data.frame(lon,lat,id)
x <- st_as_sf(x, coords=c("lon", "lat"), crs = 4326)

st_write(x, dsn = "/home/frousseu/Documents/github/spatialR/cef.gpkg", append = FALSE)

cef <- st_read("/home/frousseu/Documents/github/spatialR/cef.gpkg")


# Plot the result
plot(st_geometry(cef), axes = TRUE)

# Alternatively, plot the results with mapview
mapview(cef)



```


<br>

# COORDINATE REFERENCE SYSTEM (CRS)

```{r fig.width = 10, fig.height = 6, out.width = "70%"}

quebec <- st_read("/home/frousseu/Documents/github/spatialR/québec.gpkg")

st_crs(quebec)

```

## Different CRS

```{r fig.width = 10, fig.height = 6, out.width = "70%"}

par(mfrow = c(1,2))
plot(st_geometry(quebec), axes = TRUE)
quebec <- st_transform(quebec, 6622)
plot(st_geometry(quebec), axes = TRUE)

```


As always, when playing with spatial data, one needs to be aware of coordinate reference systems (CRS). Assigning and transforming CRS in sf can be done with the `st_transform` function. 

## Red Trillium

First, let's get some data from GBIF using the **rgbif** package. We will get occurrence data for a spring plant species, the Red Trillium (*Trille rouge*, *Trillium erectum*).

<img style="height: 400px; align: center;" src="https://inaturalist-open-data.s3.amazonaws.com/photos/342006400/medium.jpg">


## Get occurrences from GBIF
```{r proj_data, fig.width=7,fig.height=5,out.width="70%"}

library(rgbif)

occs <- occ_search(scientificName = "Trillium erectum", hasCoordinate = TRUE, stateProvince = "Québec", country = "CA", limit = 5000)
trille <- st_as_sf(occs$data, coords = c("decimalLongitude", "decimalLatitude"))
plot(st_geometry(trille), axes = TRUE)
st_crs(trille)

```
<br>
We haven't assigned a crs to the sf object.

<br>

## EPSG and CRS
<br>
See [https://epsg.io/](https://epsg.io/) to find CRS EPSG codes.
<br><br>
**4326** - WGS 84 -- WGS84 - World Geodetic System 1984, used in GPS<br>
**32198** - NAD83 / Quebec Lambert<br>
**26918** - NAD83 / UTM zone 18N<br>
**9820** - Lambert Azimuthal Equal Area<br>
**6622** - NAD83(CSRS)v2 / Quebec Lambert<br>
<br>
etc.

## Assign a CRS

Assigning a coordinate reference system can be done with the functions `st_crs` or it can be done when transforming a `data.frame` to a spatial `data.frame` with `st_as_sf`.

```{r proj_assign, fig.width=6.5,fig.height=4,out.width="70%"}

st_crs(trille) <- 4326
st_crs(trille)

```

## With `st_as_sf`
```{r proj_assign2, fig.width=6.5,fig.height=4,out.width="70%"}

trille <- st_as_sf(occs$data, coords = c("decimalLongitude", "decimalLatitude"), crs = 4326)
plot(st_geometry(trille), axes = TRUE)

```

<br>

## Change a CRS

```{r proj_assign3, fig.width=6.5,fig.height=4,out.width="70%"}

# 32198 NAD83 / Quebec Lambert
trille <- st_transform(trille, 32198)
plot(st_geometry(trille), axes = TRUE)

```

## Use a common CRS

When plotting or working with multiple spatial objects, the same CRS needs to be used!

```{r proj_assign4, fig.width = 5, fig.height = 5, out.width = "60%"}


plot(st_geometry(quebec))
plot(st_geometry(trille), add = TRUE)

```

## A note on geodata and rmapshaper

The [geodata](https://github.com/rspatial/geodata) package returns a `SpatVector` which we transform to a sf object.

The `ms_simplify` function from the [rmapshaper](https://andyteucher.ca/rmapshaper/) package is very useful to reduce the precision of polygons and maintaining the topology (and adjacent polygons).

```{r geodata, fig.width=10, fig.height=6}

library(geodata)

canada <- gadm('GADM', country='CAN', level=1) |> 
            st_as_sf() # transform a SpatVector to an sf data.frame


library(rmapshaper)

canada <- ms_simplify(canada, 0.001) # simplify shape and keep 0.1% of points

```


## Multiple CRS

Let's use Canada to more easily see the differences between some CRS.

```{r multiple_crs, fig.width=10, fig.height=6}



crs <- c(4326, 2958, 32198, 3995)

par(mfrow = c(2, 2), mar = c(2, 3, 2, 0))

for(i in 1:length(crs)){
  canada2 <- st_transform(canada, crs = crs[i])
  plot(st_geometry(canada2), axes = TRUE, main = paste("epsg", crs[i]), cex.main = 0.7)
}


```

<br>

## Geographic vs. Projected CRS

Geographic coordinates are coordinates on a sphere or on an ellipse, while projected coordinates are defined on a flat 2D surface. Usually, geographic coordinates are in latitudes/longitudes and projected coordinates are in meters. As seen earlier, this is important when doing certain spatial operations. All functions from package rgeos require that spatial objects are projected. Otherwise, functions often do not work properly because they assume that calculations are done on cartesian coordinates.

```{r proj_proj, fig.width=10, fig.height=6}

st_bbox(canada)

st_bbox(st_transform(canada, crs[3]))

```


<br>

## CRS and EPSG

The EPSG code 4326 is equivalent to giving the `"+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"` CRS to the data.
 
<br>

## -- Exercice 2 --

Play with crs exercice


```{r Ex2, include = FALSE, eval = FALSE}
canada <- gadm("GADM", country = c("USA","CAN"), level = 1) |>
    st_as_sf()
canada <- ms_simplify(canada, 0.001)


w <- world(resolution=5, level=0, path = getwd(), version="latest") |>
       st_as_sf()

plot(w)

w <- st_transform(canada, 5937)
w <- st_transform(w, 102016)
w <- st_transform(canada, 3995)
w <- st_transform(w, 54030)
w <- st_transform(w, 53045)

```

<!--

## -- Exercice 2 --

Generate a set of 50 200km random buffers across Canada and measure the proportion of overlap between **each pair** of buffers.

*Note: The `dist` argument in st_buffer takes the values in the coordinate reference system. If coordinates are in lat/lon, a value of 1 means 1 degre. If values are in meters, a value of 1 means 1 meter. It is better to work in meters with a projected system*

```{r exA, eval=FALSE}

library(geodata)
can <- gadm('GADM', country = 'CAN', level = 1) |> st_as_sf()

```

<br>

-->

<!-- ### -- Solution -- -->

<!-- NEEDS TO FIX THIS!!!!!!!!
```{r exAsol, out.width="60%", echo=FALSE, eval = FALSE, include=FALSE, fig.height=5, fig.width=5}

# first set the seed from the random generator to get reproducible results 
set.seed(123)

# get shapefile for Canada
can<-raster::getData('GADM',country='CAN',level=1)
can<-spTransform(can,CRS("+proj=laea +lat_0=60 +lon_0=-100 +ellps=GRS80"))
plot(can,border=gray(0.25))

# throw random points
n<-50
p<-spsample(can,n,type="random")

# get buffers
b<-gBuffer(p,width=200*1000,byid=TRUE)
b<-SpatialPolygonsDataFrame(b,data.frame(id=1:n))

# plot them
plot(b,add=TRUE)
text(coordinates(b),label=b$id)

# build a data.frame to store each pairs
e<-expand.grid(id1=b$id,id2=b$id)

# compute the percent of overlap between each pair
o<-sapply(1:nrow(e),function(i){
  x1<-b[b$id==e[i,1],]
  x2<-b[b$id==e[i,2],]
  g<-gIntersection(x1,x2)
  if(is.null(g)){ # if both buffers do not overlap, return 0
    0
  }else{
    gArea(g)/gArea(x1) # otherwise, return the proportion between the overlapping area and the given buffer
  }
  #  
})
e$o<-o

# plot results
plot(e[,1],e[,2],cex=2*e$o,xlab="id 1",ylab="id 2",asp=1)

```

-->

<!-- This is probably not the most efficient way. Using `gIntersection(b, b, byid = TRUE)` returns the 132 overlapping pairs faster, but ids need to be constructed to associate the different intersections to the correct pairs. Also, since the buffers all have the same dimension, we don't need the proportion of overlap for each ids as it is symmetric within each pair.   -->

<br>


## Spatial operations

Most spatial operations are available in the package `sf`. One of the requirement for functions to work well for spatial operations in `sf` is that objects **are in a projected coordinate system** (i.e. not in lat/lon 4326). This can be checked with `st_is_longlat`.


```{r isprojected}

st_is_longlat(trille)
st_is_longlat(quebec)
st_is_longlat(canada)

```


```{r quebec, include = FALSE}

library(geodata)
library(rmapshaper)


canada <- gadm("CAN", level = 1, path = "Canada") |> st_as_sf()
canada <- ms_simplify(canada, 0.001)

st_write(canada, "/home/frousseu/Documents/github/spatialR/canada.gpkg", append = FALSE)

st_write(canada[canada$NAME_1=="Québec",], "/home/frousseu/Documents/github/spatialR/québec.gpkg", append = FALSE)

qc <- gadm("CAN", level = 2, path = "Québec") |> st_as_sf() 
#sherbrooke <- qc[qc$NAME_1 == "Québec" & qc$NAME_2 == "La Région-Sherbrookoise", ]  
outaouais <- qc[qc$NAME_1 == "Québec" & qc$NAME_2 == "Communauté-Urbaine-de-l'Outaouai", ] 

st_write(outaouais, "/home/frousseu/Documents/github/spatialR/outaouais.gpkg", append = FALSE)

```


### Intersections

The function over from package sp is used to determine whether different entities overlap. It returns a vector or a data.frame with the identities or the characteristics of overlapping elements.

```{r overlay1, fig.width=7,fig.height=4,out.width="100%"}


outaouais <- st_read("/home/frousseu/Documents/github/spatialR/outaouais.gpkg")

trille <- st_transform(trille, st_crs(outaouais))

plot(st_geometry(outaouais), axes = TRUE)
plot(st_geometry(trille), add = TRUE)

```


#### Interactive map
```{r overlay2, fig.width=7,fig.height=4,out.width="100%", out.height=550}

mapview(outaouais) + mapview(trille)

```

#### Intersecting
```{r overlay3, fig.width=6,fig.height=5,out.width="100%"}

s <- st_intersects(trille, outaouais) |>
        lengths()

trilleout <- trille[s == 0, ]
trillein <- trille[s > 0, ]

plot(st_geometry(outaouais), axes = TRUE)
plot(st_geometry(trillein), pch = 16, col = "red", add = TRUE)
plot(st_geometry(trilleout), pch = 16, col = "blue", add = TRUE)

```

#### Intersecting 2nd version

Another more compact way of getting only the occurrences that are in the outaouais polygon.
```{r overlay4, fig.width=7,fig.height=4,out.width="100%"}

trillein <- trille[outaouais, ]

```

<!-- As can be seen in the help files for `?over`, if the second object is a spatial object without attributes, a vector with the same length as the first element is returned with the first overlapping id in the second element.If the second element has attribute data, attribute data are returned. -->



```{r points_op, fig.width=7,fig.height=4,out.width="100%", eval = FALSE, include = FALSE}

x <- trillein

# list of functions to apply
op<-c("st_centroid","st_concave_hull","st_convex_hull","st_buffer","st_voronoi")
# set the graphic window
par(mfrow=c(2,3),mar=c(0,0,3,0))
# apply all operations
for(i in seq_along(op)){
  plot(x,main=op[i],xlim=c(-2,2),ylim=c(-3,3))
  plot(get(op[i])(x),col=gray(0.5,0.5),add=TRUE,cex=3)
}

```

### Operations on points

Here are some common operations that can be done on points (but also on lines or on polygons). 

```{r points_op2, fig.width = 7, fig.height = 6, out.width="100%"}

x <- trillein
st_is_longlat(x)
x <- st_transform(x, 32198) # use a projected crs

par(mfrow = c(2, 3), mar = c(0, 0, 1, 0))

x2 <- st_union(x) |>
        st_centroid() |>
        st_geometry()

plot(st_geometry(x), main = "st_centroid")
plot(x2, pch = 16, cex = 2, col = "red", add = TRUE)

x2 <- st_union(x) |>
        st_convex_hull() |>
        st_geometry()

plot(st_geometry(x), main = "st_convex_hull")
plot(x2, pch = 16, cex = 3, border = "red", add = TRUE)

x2 <- st_union(x) |>
        st_concave_hull(ratio = 0.20) |>
        st_geometry()

plot(st_geometry(x), main = "st_concave_hull")
plot(x2, pch = 16, cex = 3, border = "red", add = TRUE)

x2 <- st_buffer(x, dist = 2000) |>
        st_geometry()

plot(st_geometry(x), main = "st_buffer on each point")
plot(x2, pch = 16, cex = 3, border = "red", add = TRUE)

x2 <- st_union(x) |>
        st_buffer(dist = 2000) |>
        st_geometry()

plot(st_geometry(x), main = "st_buffer on all points")
plot(x2, pch = 16, cex = 3, border = "red", add = TRUE)

```

<br>

### A note on `st_union`

The function `st_union`is used to combine geometries together. This is useful if we want to apply an operation on each feature or on all combined features.
```{r union1, fig.width = 7, fig.height = 6, out.width="80%"}

dim(x)
dim(st_union(x))
length(st_union(x))

```


```{r union2, fig.width = 7, fig.height = 6, out.width="80%"}

head(x) # several points
head(st_union(x)) # on set of MULTIPOINT

```

### Operations on polygons

First, let's create two polygons with buffers around some Red Trillium observations.

```{r polygons_op, fig.width=7, fig.height=6, out.width = "80%"}

# construct two buffers
x1 <- st_buffer(x[38, ], dist = 4000)
x2 <- st_buffer(x[23, ], dist = 2000)

plot(st_geometry(rbind(x1, x2)), axes = TRUE) # bind them in the same object
     
```
     
### Overlapping polygons

Here are some common overlapping operations that are done on polygons.     

```{r polygons_op2, fig.width=7, fig.height=6, out.width = "80%"}

# list of functions to apply
op <- c("st_intersection", "st_difference", "st_sym_difference", "st_union")
# set the graphic window
par(mfrow = c(2, 2),mar = c(0, 0, 3, 0))

limits <- st_union(x1, x2) |> st_bbox()
xlim <- limits[c(1, 3)]
ylim <- limits[c(2, 4)]

for(i in seq_along(op)){
  plot(st_geometry(x1), main = op[i], xlim = xlim, ylim = ylim)
  plot(st_geometry(x2), add = TRUE)
  plot(st_geometry(get(op[i])(x1, x2)), add = TRUE, col = "forestgreen") # this is just a way to get all functions defined in op
}

```

<br>

### Measure distances

Here, let's measure the distance between each points and their centroid.
```{r measure_distance, fig.width=7, fig.height=6, out.width = "80%"}

cx <- st_union(x) |> st_centroid()
plot(st_geometry(x), axes = TRUE)
plot(st_geometry(cx), add = TRUE, col = "red", pch = 16, lwd = 3)
text(st_coordinates(x), label = round(as.numeric(st_distance(x, cx))/1000, 1), adj = c(-0.5, 1.5), cex = 0.6)
mtext(side = 3, line = 0, text = "Distance in km from centroid", ad = 0.98)

```
 

### Measure areas

```{r measure_area, fig.width=7,fig.height=6,out.width="80%"}

set.seed(123)

pol <- st_buffer(x[1:2, ], dist = runif(nrow(x[1:2, ]), 1000, 3000))
area <- st_area(pol)
plot(st_geometry(pol), axes = TRUE)
text(st_coordinates(st_centroid(pol)), label = paste(round(as.numeric(area)/1000),"km"))

```

<br>

### Sample

Sample points in polygons in different ways using the `st_sample` function.

```{r sample, fig.width=7,fig.height=5,out.width="70%"}

set.seed(12345)
n<-20
type<-c("random","regular","hexagonal") # list sampling types
par(mfrow = c(2, 2), mar = c(0, 0, 2, 0)) # set graphic window

# plot the different sampling types
for(i in seq_along(type)){
  s <- st_sample(pol, n, type = type[i])  # get random points
  plot(st_geometry(pol), main = type[i], font = 2) # plot polygon
  plot(st_geometry(s), pch = 1, add = TRUE) # plot random points
}
s <- st_sample(pol, rep(n, nrow(pol)), type = type[1])  # get random points
plot(st_geometry(pol), main = type[1], font = 2) # plot polygon
plot(st_geometry(s), pch = 1, add = TRUE) # plot random points

```


<!-- Random points can also be distributed within random polygons 
```{r sample2, fig.width=7,fig.height=5,out.width="70%", eval = FALSE, include = FALSE}

set.seed(12345)

N<-10 # number of random polygons
n<-5 # number of random points within each polygons

plot(pol)
# sample points and build buffers around them
s1<-gBuffer(spsample(pol,N,type="random"),byid=TRUE,width=0.1) 
# plot buffers
plot(s1,add=TRUE) 
# sample points in each polygon
s2<-sapply(s1@polygons,spsample,n=n,type="random") 
# bind points in the same spatial object
s2<-do.call("rbind",s2) 
# plot points
plot(s2,add=TRUE)

```
-->

<br>

### Combine operations

Here is an example were we combine several operations to determine the length of roads within each random buffer in a region using the previous road data.

Let's build the random buffers and see the results. 

```{r over, fig.width=8,fig.height=7,out.width="60%",echo=TRUE}
set.seed(1234) # set the seed to obtain the same result each time
n <- 10
b <- st_convex_hull(st_union(roads)) # determine the bounding box of the road system
s <- st_sample(b, n, type = "random") # throw random points within the bounding box
buffs <- st_buffer(s, dist = 10000) # turn the points to buffers

plot(st_geometry(roads), col = gray(0.7), axes = TRUE)
text(st_coordinates(s), labels = names(buffs))
plot(buffs, border = NA, col = gray(0, 0.1), add = TRUE)
```

<br>

Extract all road sections that intersect with a buffer.

```{r over2, fig.width=8,fig.height=7,out.width="60%",echo=-(1:9)}
<<over>>
int <- st_intersection(buffs, roads, byid = TRUE)
plot(int, col = "red", lwd = 4, add = TRUE)
```

<br>

Then determine the list of road sections touching each buffer.

```{r over3, fig.width=8,fig.height=7,out.width="60%",echo=-(1:11),fig.show="hide"}
<<over2>>
o <- st_intersects(buffs, int)
o
```

<br>

Finally, calculate the total length of roads inside each buffer.

```{r over4, fig.width=8,fig.height=7,out.width="60%",echo=-(1:13),results="hide"}
<<over3>>
dist <- sapply(o, function(i){
  sum(st_length(int[i]))  
})
text(st_coordinates(st_centroid(buffs)), labels = round(dist/1000,1), col = "black", adj = c(-0.75,-1.5), xpd = TRUE, cex = 1)
```

<br>

### Simplify things

```{r simplify, out.width="80%", eval=TRUE, include=TRUE}

plot(st_geometry(canada))
plot(st_geometry(st_simplify(canada, preserveTopology = TRUE, dTolerance = 50000)), border = "red", add = TRUE)

ms_simplify(canada, 0.2) |>
  st_geometry() |>
  plot()

```

<br>

<!-- ### Rotate or MST -->

<!-- ## Plotting -->

<!-- ### plot -->



<!--

```{r plot2, out.width="50%", eval=FALSE, echo=FALSE}

par(mar=c(0,0,0,0))
plot(ch,border="red",col="blue",lwd=10)

```

-->

<!-- ### spplot -->

<!-- Do an spplot on something -->

## -- Exercice 3 --

Calculate the proportion of forest in 10 random buffers across a landscape. Let's first generate a fictious landscape.

```{r ex0, tidy=FALSE, out.width="60%"}

set.seed(123)

#x<-runif(100, -74, -71) # generate random points
#y<-runif(100, 45, 47)


h <- x |> # turn it to spatial points 
     st_as_sfc() |> 
     st_buffer(dist = 300 * rgamma(nrow(x), 2, 1)) |> # build random gamma buffers around them 
     lapply(function(i){st_as_sfc(st_bbox(i))}) |>
     do.call("c", args = _) |>
     st_union() # put them all in a single polygon
   
plot(h, col = "green4", border = NA, axes = TRUE)

```

<!-- ### -- Solution -- -->

```{r ex0sol, echo=FALSE, include=FALSE, tidy=FALSE, out.width="60%"}

# First throw 10 random points within the envelope of the landscape and then generates buffers around these points
b <- st_convex_hull(h) |>
     st_sample(10, type = "random") |>
     st_buffer(dist = 1000)


# Plot the buffers
plot(h, col = "green4", border = NA, axes = TRUE)
plot(b, add = TRUE)

# Intersect the buffers with the forest and plot the result
cuts <- st_intersection(b, h)
plot(cuts, add = TRUE, col = "red", border = NA)

int <- lengths(st_intersects(b,h))

ifelse(int, 0, st_area(cuts) / st_area(b))

# Compute the proportion of forested areas within each buffer
#pa <- gArea(int, byid = TRUE) / gArea(b, byid = TRUE)

# Add the value on the plot
#text(coordinates(b), label = round(pa, 2))

```


# RASTERS (terra)

## What is a raster?

A raster is a regular grid of pixel with values. Here is an example of building a simple raster with random values using the [`terra`](https://rspatial.github.io/terra/) package.
```{r buildrastersimple, out.width = "70%"}
library(terra)

n <- 200
r <- rast(nrow = n, ncol = n, ext = ext(canada), crs = crs(canada))
r <- setValues(r, runif(n^2, 0, 1))
ncell(r)
plot(r)
plot(st_geometry(canada), add = TRUE)

```

<br>

<!-- ## Raster formats -->

<!-- Rasters can be held in memory or on disk when they are too big. -->

## Read and write

Writing a raster to a file is done with the `writeRaster` function.

```{r write_rast, out.width="70%"}

writeRaster(r, "/home/frousseu/Documents/github/spatialR/data/rast.tif", overwrite = TRUE)
list.files("/home/frousseu/Documents/github/spatialR/data")

```

<br>

Reading can be done directly with the `rast` function.
 
```{r read_rast, out.width="70%"}

r1 <- rast("/home/frousseu/Documents/github/spatialR/data/cdem_dem_031F.tif")
r2 <- rast("/home/frousseu/Documents/github/spatialR/data/cdem_dem_031G.tif")

par(mfrow=1:2)
plot(r1)
plot(r2)

```


<br>

## Aggregate, merge and crop

Rasters can be aggregated, merged or cropped. An aggregation reduces the number of cells by a certain factor, while a merge brings two rasters together.
```{r merge, out.width="70%"}

ncell(r1)

r1 <- aggregate(r1, fact = 10)
r2 <- aggregate(r2, fact = 10)

ncell(r1)

r <- terra::merge(r1, r2) # mosaic could also be used if rasters overlap
plot(r)

```

<br>

Rasters can be cropped with a specific region using the `extent` argument.
```{r crop, out.width="70%"}

e <- ext(-76.5, -75.0, 45.2, 45.8)
plot(crop(r, e)) 
plot(st_geometry(outaouais), add = TRUE)

plot(crop(r, outaouais))
plot(st_geometry(outaouais), add = TRUE)

crop(r, outaouais) |>
  mask(outaouais) |>
  plot()
plot(st_geometry(outaouais), add = TRUE)

```

<br>

## Dimensions

Rasters can have a single or multiple layers. However, layers need to be of the same exact dimensions and resolution.

```{r stack1}

r
dim(r)
ncell(r)
nlyr(r)

```

## Memory

When reading rasters on your computer, often they will not be brought into memory. The object created will just be a pointer to a file. This is to reduce the memory footprint of rasters.

```{r stack2}

inMemory(r)

lc <- rast("WorldCover_trees_30s.tif")
inMemory(lc)

```

<br>

## Cropping and masking
```{r stack3, out.width="80%",fig.height=5, fig.width=7}

lc <- rast("WorldCover_trees_30s.tif")
inMemory(lc)

f <- crop(lc, canada) # crop to Canada extent
plot(f)
f <- mask(f, canada) # mask to the Canada geometry
plot(f)
f <- crop(lc, canada, mask = TRUE) # crop and mask to Canada extent
plot(f)


```

## Projecting
```{r stack4, out.width="80%",fig.height=5, fig.width=7}

f <- project(lc, r)

```
<br>

The function `project` will take what is in `lc` and put it in the resolution and extent of `r`.


## Stack rasters together

```{r stack5, out.width="80%",fig.height=5, fig.width=7}

forest <- f
names(f) <- "forest"

elevation <- r
names(elevation) <- "elevation"

env <- c(forest, elevation)

dim(env)
env

```


<br>

## A note on reprojecting rasters
<br><br>
Each time a raster is projected or transformed, the original values will be modified and calculation will be done to fit it in the new dimensions and resolution of the output raster. Original values are lost. Thus, **it is always better to transform the crs of vectors to fit it to a raster than vice versa**.



## Raster operations

### Extract

Let's extract elevation data for the Red Trillium occurrences we got previously.

```{r extract0}

x <- trillein
x <- st_transform(x, st_crs(elevation))

plot(elevation)
plot(st_geometry(outaouais), add = TRUE)
plot(st_geometry(x), add = TRUE)

```

<br>

```{r extract}

e <- extract(elevation, x)
head(e)
elevation
hist(e[, 2] , xlab = "Altitude", main = "")

```


### Extract multiple layers
```{r extract}

e <- extract(env, x)
head(e)


```


<br>

### `exactextractr`

[`exactextractr`](https://isciences.gitlab.io/exactextractr/) is an R package designed for faster extractions using C++. It is usually faster than the function `terra::extract`. It also makes exact extractions, i.e. it takes into account the proportion of cells that are overlapping with the polygons. This can also be done with `terra::extract` and the argument `exact = TRUE`, but it is much slower.

```{r velox0, eval = FALSE, include = FALSE}
library(exactextractr)

buff <- st_buffer(x, dist = 500)

plot(crop(elevation, outaouais))
plot(st_geometry(outaouais), add = TRUE)
plot(st_geometry(buff), add = TRUE)

exact_extract(elevation, buff , fun = "mean")
```

<br>

### Reclassify

```{r reclassify}

mn <- c(0, 50, 100, 150, 200, 400) # min
mx <- c(50, 100, 150, 200, 400, 600) # max
mat <- cbind(mn, mx,lab = mx)
mat
elevationclass <- classify(elevation, mat)
plot(elevationclass, col = rev(terrain.colors(nrow(mat))))
plot(st_geometry(outaouais), add = TRUE)

```

<br>

### Rasterize

Here is an example of building a raster where each pixel value is determined by the number of points in each cell. For this, we use the `rasterize` function.

```{r buildrastercomplex2}

trille <- st_transform(trille, 32198)

rtrille <- rast(resolution = 20000, ext = ext(trille))

rtrille <- rasterize(trille, rtrille, field = 1, fun = "count", background = 0)

rtrille[rtrille == 0] <- NA # replace cells with 0 observation with NA's to better visualize data

rtrille

```

<br>
### Plot the results

```{r buildrastercomplex3, out.width="60%"}


plot(rtrille)
plot(st_geometry(trille), col = gray(0, 0.25), add = TRUE) 
plot(st_geometry(st_transform(canada, st_crs(trille))), add = TRUE)


```


<br>

### Build a rasters from distances

Measure distances from roads and store the values in a raster.

```{r measure_raster, out.width="60%"}

roads2 <- st_transform(roads, 32198)

r <- rast(resolution = 1000, ext= ext(roads2))

rcentroids <- xyFromCell(r, 1:ncell(r)) |>
  as.data.frame() |>
  st_as_sf(coords = c("x", "y"), crs = st_crs(roads2))

g <- st_distance(rcentroids, st_union(roads2))

class(g)
dim(g)

r <- setValues(r, g[, 1])

plot(r)
plot(st_geometry(roads2), add = TRUE)

```

<br>

### Rasterize with lengths

An example on using rasterizeGeom to compute the length of roads within each pixel of a raster.

```{r road_density, out.width="60%"}

test <- rasterizeGeom(vect(roads2), aggregate(r, 10), fun = "length")
plot(test)
plot(st_geometry(roads2), add = TRUE)

```

<br>

<!-- ### Random walk -->

<!-- An example of extracting the distance to a road for each location of a random walk -->

### Extract values from a path

```{r rw, out.width="60%", eval=FALSE, echo=FALSE, include=FALSE}

set.seed(123)

n <- 1000
e <- ext(r)

x<-c(ext(r)[1]) + cumsum(rnorm(n, 0, 2000) + 500)
y<-c(ext(r)[3]) + cumsum(rnorm(n, 0, 2000)+ 500)

rw <- data.frame(x, y) |>
        st_as_sf(coords = c("x", "y"), crs = st_crs(r)) |>
        st_combine() |>
        st_cast("LINESTRING") |>
        st_as_sf()

plot(r)
plot(st_geometry(roads2), add = TRUE)
plot(rw, add = TRUE, col = "red", lwd = 2)

e <- extract(r, rw)

hist(e[, 2])


```

<br>

### Contours

Convert rasters values to contours in a SpatialLines object.

```{r raster2cont, out.width="70%"}

con <- as.contour(r)
con
plot(r)
plot(con, add = TRUE)

```

<!-- ### Rasterizing a polygon -->

```{r rasterizepol, out.width="70%", eval=FALSE, include=FALSE}
set.seed(1234)

poly <- spatSample(r, 1, as.points = TRUE) |>
          st_as_sf() |>
          st_buffer(dist = 40000)

plot(r)
plot(st_geometry(poly), add = TRUE)


pr <- rasterize(poly, r)
pr
plot(pr)

```

<br>

### Polygonize a raster

Turn all cells that are at least 25km from the roads to polygons.

```{r polygonize}

r25 <- r
r25[r25 < 25000] <- NA 

pr <- as.polygons(r25, aggregate = TRUE) |>
        st_as_sf()
plot(r)
plot(st_geometry(pr), col = "blue", border = NA, add = TRUE)

```


## -- Exercice 4 --

Get data for *Trillium cernuum* using package `rgbif` and calculate the mean annual temperature in the species range. [Bioclimatic variables](http://worldclim.org/bioclim) are described in the WorldClim pages.

Here is how to download the data. Note that the object returned by `occ_search` is a gbif object from which the data element need to be extracted. This element is a `tibble` that needs to be turned to a `data.frame` in order to convert it to a spatial object.

```{r ex2, eval=FALSE}

# download temperature data
tavg <- worldclim_country("CAN", var = "tavg", path = getwd())
tavg <- mean(tavg)

# download records
x <- occ_search(scientificName = "Trillium erectum", limit = 1000, hasCoordinate = TRUE, country = "CA")
x <- as.data.frame( x$data)

```

<br>

<!-- ### -- Solution -- -->

```{r ex2sol, out.width="100%", dev.args=list(pointsize=9), echo=FALSE, include=FALSE}

# download temperature data
tavg <- worldclim_country("CAN", var = "tavg", path = getwd())
tavg <- mean(tavg)

# download Trillium data
x <- occ_search(scientificName = "Trillium erectum", limit = 1000, hasCoordinate = TRUE, country = "CA")

# get the records in a spatial object
x <- as.data.frame(x$data) |>
       st_as_sf(coords = c("decimalLongitude", "decimalLatitude"), crs = 4326)


# reduce raster size to the bounding box of the records
tavg <- terra::crop(tavg, ext(x))

# get convex hull of distribution
a <- st_union(x) |> 
       st_convex_hull() |>
       st_as_sf()

# check data
plot(tavg)
plot(st_geometry(x), add = TRUE)
plot(st_geometry(a), add = TRUE)


# extract values within the range of the species
e <- extract(tavg, vect(a))

# check distribution of values for mean annual temperature and precipitation
hist(e[,2], xlab = "")


```


# MAPPING

## STATIC

### `plot`

```{r map_plot, out.width="70%", dev.args=list(pointsize=9)}



```

### `spplot`

```{r spplot_map, out.width="70%", dev.args=list(pointsize=9)}


```

### `levelplot`

```{r levelplot, out.width="70%", dev.args=list(pointsize=9)}



```

<br>

### `ggspatial`

```{r ggspatial_map, out.width="70%", dev.args=list(pointsize=9)}

library(ggplot2)
library(tidyterra)



ggplot()+
  geom_spatraster(data = tavg) +
  geom_sf(data = trille, color = "orange", alpha = 0.8) +
  geom_sf(data = canada, color = "white", fill = NA, alpha = 0.8) +
  coord_sf(xlim = ext(tavg)[1:2], ylim = ext(tavg)[3:4], expand = FALSE) +
  theme_light()


```

<br>

### `OpenStreetMap`

```{r OSM, fig.keep="last"}


```

<br>

### `ggmap`

```{r ggmap}


```

<br>

## INTERACTIVE

### Drawing polygons

select, drawPoly from package raster to interactively select elements

```{r drawPoly}




```

<br>



### `leaflet`

Here present leaflet and leafletExtras

```{r leaflet1, tidy=FALSE, message=TRUE, warning=TRUE, eval = FALSE}

library(leaflet)
library(leaflet.extras)

leaflet(cat) %>% 
  addTiles() %>%
  addCircleMarkers(data = cat, group = 'cat') %>%
  addDrawToolbar(targetGroup = 'cat', editOptions = editToolbarOptions(selectedPathOptions = selectedPathOptions())) %>%
  addLayersControl(overlayGroups = c('cat'),options =layersControlOptions(collapsed=FALSE)) %>%
  addMeasurePathToolbar(options =measurePathOptions(imperial = TRUE,minPixelDistance = 100,showDistances = FALSE))


```

<br>

### `tmap` 

```{r tmap, out.width="100%"}

cat$attack<-as.factor(cat$Attack)

library(tmap)

#tmap_mode("static")

canada$area <- as.numeric(st_area(canada))

tm_shape(canada)+
  tm_polygons(fill = "area")#+
#  tm_shape(trille)+
#  tm_dots("attack")+
#  tm_layout(basemaps=c("Esri.WorldImagery","Esri.WorldShadedRelief","Esri.NatGeoWorldMap"))

```



<br>

### `mapedit`

Here is a test with using [mapedit](http://r-spatial.org/r/2017/06/09/mapedit_0-2-0.html) functionality.

```{r mapedit, eval = FALSE}

library(mapview)
library(mapedit)

x <- mapview(trille) |>
       editMap()

x <- x$drawn

plot(st_geometry(x))

mapview(trille) +
  mapview(x)



```

<br>

<!-- # -- EXERCICE 3  -->

<!-- Generate random home ranges in a region and measure percent overlap between them. -->

<!-- ## SOLUTION  -->

```{r exercices3hr, eval=FALSE}



```
# MORE POSSIBILITIES

The main book for learning to use R for spatial data is probably [Applied Spatial Data Analysis with R](http://www.asdar-book.org/) by Bivand et al. (2013)

| Package | Use |
| :-------------:|:----------------------------------------|
| **spatstat** | Huge package mainly for analysing spatial point patterns | 
| **adehabitat** | A collection of packages for studying habitat selection |
| **gstat** | Variograms, geostatistics, kriging, etc. | 
| **SDMTools** | Tools for Species Distribution Modeling | 
| **spdep** | Tools for studying spatial dependence |

<br>

## Spatial Task View

The [Spatial Task View]() on maintained on CRAN is worth a visit if you are searching for more possibilities.

## rspatial.org

A good online reference for doing spatial analyses with R is [rspatial.org](rspatial.org) which provides lots of examples on diferent types of analyses.

<!--![rspatial.org](/home/frousseu/Documents/github/spatialR/rspatial.png)--> 

<br>

## Special packages

### Landscape metrics with `SDMTools` or `spatialEco`

```{r metrics1, eval = FALSE, include = FALSE}

library(SDMTools)
library(spatialEco)


r <- raster(nrows=200, ncols=200, xmn=0, xmx=100, ymn=0, ymx=100)

x<-runif(100,0,100)
y<-runif(100,0,100)

h<-gUnaryUnion(gEnvelope(gBuffer(SpatialPoints(cbind(x,y)),width=rpois(length(x),4),byid=TRUE),byid=TRUE))

r<-rasterize(h,r)

plot(r,col="green4")

x <- sampleRandom(r,1, na.rm = TRUE, sp = TRUE)
pol<-SpatialPolygonsDataFrame(gBuffer(x,width=20),data.frame(id=1),match.ID=FALSE)

a<-land.metrics(x=pol,y=r,metrics = c(2:38))

plot(pol,add=TRUE)
#plot(rasterToPolygons(r),add=TRUE)
plot(x,add=TRUE)

Scalebar(x=90,y=3,distance=20,unit='m',scale=1)

a
```

<!-- ### Spatial statistics with `spatstat` -->

<!-- ### Spatial dependence with `spdep` -->

<!-- Show an example of computing Moran's I on a SpatialPolygons of ecodistricts. -->

<!-- ### Kriging with `gstat` -->

<!-- library(gstat) -->

<!-- v <- variogram(elev~1,data=eco2,cutoff=2500000,width=10000) # calculates sample variogram values  -->
<!-- plot(v) -->
<!-- vfit <- fit.variogram(v, model=vgm("Sph")) # fit model -->

<!-- plot(v,vfit) -->

<br>

<!-- ### kriging -->

```{r spatialcorr, eval=FALSE, include = FALSE, echo=FALSE}

library(foreign)

url<-"http://sis.agr.gc.ca/cansis/nsdb/ecostrat/district/ecodistrict_shp.zip"
path<-getwd()
#download.file(url,destfile=paste(path,"eco.zip",sep="/"))
#unzip(paste(path,"eco.zip",sep="/"))
eco<-readOGR(paste(path,"Ecodistricts",sep="/"),"ecodistricts")
eco<-spTransform(eco,CRS("+proj=laea +lat_0=55 +lon_0=-100 +ellps=GRS80"))

eco$lon<-coordinates(eco)[,1]
eco$lat<-coordinates(eco)[,2]

#url<-"http://ftp.geogratis.gc.ca/pub/nrcan_rncan/archive/vector/ecosystems/ecodistrict/ecodist.shp.zip"
#path<-"C:/Users/rouf1703/Documents/temp"
#path<-getwd()
#download.file(url,destfile=paste(path,"eco2.zip",sep="/"))
#unzip(paste(path,"eco2.zip",sep="/"))
#eco<-readOGR(paste(path,sep="/"),"ECODIST")


#download.file("http://sis.agr.gc.ca/cansis/nsdb/ecostrat/district/dt_temp.dbf",destfile=paste(path,"dt_temp.dbf",sep="/"))
temp<-read.dbf(paste(path,"dt_temp.dbf",sep="/"))

#download.file("http://sis.agr.gc.ca/cansis/nsdb/ecostrat/district/dt_elevation.dbf",destfile=paste(path,"dt_elevation.dbf",sep="/"))
elev<-read.dbf(paste(path,"dt_elevation.dbf",sep="/"))

eco$elev<-elev$MEAN_ELEV[match(eco$ECODISTRIC,elev$DISTRICT)]
#eco$elev[eco$elev<(-50)]<-NA

eco$temp<-temp$TMEAN_ANN[match(eco$ECODISTRIC,temp$DISTRICT)]
eco$temp[eco$temp<(-50)]<-NA

eco<-eco[!is.na(eco$elev) & !is.na(eco$temp),]
# eco$temp<-sample(eco$temp)
eco2<-eco[sample(1:nrow(eco),floor(nrow(eco)/5)),]

library(gstat)

v <- variogram(elev~1,data=eco2,cutoff=2500000,width=10000) # calculates sample variogram values 
plot(v)
vfit <- fit.variogram(v, model=vgm("Sph")) # fit model

plot(v,vfit)

### kriging

r<-raster(eco,ext=extent(eco),ncol=200,nrow=200)

P<-SpatialPointsDataFrame(SpatialPoints(coordinates(r),proj4string=CRS(proj4string(eco))),data.frame(id=1:ncell(r)))
o<-as.logical(sapply(over(P,eco,returnList=TRUE),nrow))
p<-P[o,]
k<-krige(elev~1,eco2,p,model=vfit)

P$val<-rep(NA,nrow(P))
P$val[o]<-k@data[,1]

r<-setValues(r,P$val)
plot(P,col=colo.scale(P$val),pch=16)

par(mfrow=c(1,2))
plot(r,col=rev(colo.scale(1:100,rev(c("darkred","yellow","green","blue","violet")))))
plot(eco,col=colo.scale(eco$elev,c("darkred","yellow","green","blue","violet")))

par(mfrow=c(1,2),mar=c(0,0,0,0))
plot(r,col=colo.scale(1:100,c("brown","orange","lightgoldenrod","green","darkgreen")),box=FALSE)
plot(eco,col=colo.scale(eco$elev,c("brown","orange","lightgoldenrod","green","darkgreen")),border=NA)



#par(mfrow=c(1,2))
#plot(r,col=rev(colo.scale(1:100,rev(c("darkred","yellow","green","blue","violet")))))
#plot(eco,col=colo.scale(eco$elev,c("darkred","yellow","green","blue","violet")))

par(mfrow=c(1,2),mar=c(0,0,0,0))
plot(r,col=colo.scale(1:100,c("brown","orange","lightgoldenrod","green","darkgreen")),box=FALSE)
plot(eco,col=colo.scale(eco$elev,c("brown","orange","lightgoldenrod","green","darkgreen")),border=NA)

```

<!-- ### Animal movements with `adehabitat` and `trip` -->

<!-- ### Spatial Autocorrelation -->



<!-- ### Kernel smoothing with `ks` -->

<!-- ### Great circles with `geosphere` -->

<!-- ## Extensions -->

<!-- ### RQGIS -->

<!-- ### RpostGIS -->

<!-- ### RGRASS -->

# `sf`: SIMPLE FEATURES FOR R

[Vignette 1](https://cran.r-project.org/web/packages/sf/vignettes/sf1.html)

- S3 class
- Interacts with the tidyverse and dplyr
- Easy conversion from **sp** to **sf**


- Teluq R spatial
- Geocomputations with R


